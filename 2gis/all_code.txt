
################################################################################
FILE: AppModel.swift
SIZE: 1051 bytes

################################################################################
//
//  AppModel.swift
//  2gis
//
//  Created by Павел on 04.10.2025.
//

import SwiftUI

/// Maintains app-wide state
@MainActor
@Observable
class AppModel {
    let immersiveSpaceID = "ImmersiveSpace"
    enum ImmersiveSpaceState { case closed, inTransition, open }

    // 👇 новый флаг режима
    enum UIMode { case immersive, menu }
    var uiMode: UIMode = .immersive

    enum SceneSelection: String, CaseIterable, Equatable, Hashable {
        case arrow
        case cube
    }

    var immersiveSpaceState = ImmersiveSpaceState.closed
    var selectedScene: SceneSelection = .arrow

    // ✅ Добавь этот флаг — используется в ContentView для одноразового открытия окон
    var hasOpenedArrowWindowOnce: Bool = false

    // Дистанция для стрелки (м) с жёстким клэмпом 1...5
    private(set) var arrowDistance: Float = 1.5
    func setArrowDistance(_ meters: Float) {
        arrowDistance = max(1.0, min(5.0, meters))
    }
}

################################################################################
FILE: ArrowView.swift
SIZE: 1737 bytes

################################################################################
import SwiftUI

struct ArrowView: View {
    @State private var pulse = false

    var body: some View {
        GeometryReader { geo in
            let size  = min(geo.size.width, geo.size.height)
            let inset = size * 0.1

            ArrowShape()
                .fill(LinearGradient(colors: [Color.cyan, Color.blue],
                                     startPoint: .top, endPoint: .bottom))
                .shadow(color: Color.cyan.opacity(0.5), radius: 16, y: 8)
                .overlay {
                    ArrowShape()
                        .stroke(Color.white.opacity(0.6), lineWidth: 2)
                }
                .scaleEffect(pulse ? 1.05 : 1.0, anchor: .center)
                .animation(.easeInOut(duration: 1.6).repeatForever(autoreverses: true), value: pulse)
                .frame(width: size - inset * 2, height: size - inset * 2)
                .position(x: geo.size.width / 2, y: geo.size.height / 2)
        }
        .onAppear { pulse = true }
    }
}

private struct ArrowShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let w = rect.width
        let h = rect.height
        let headH = h * 0.4

        path.move(to: CGPoint(x: w / 2, y: 0))
        path.addLine(to: CGPoint(x: w,       y: headH))
        path.addLine(to: CGPoint(x: w * 0.68,y: headH))
        path.addLine(to: CGPoint(x: w * 0.68,y: h))
        path.addLine(to: CGPoint(x: w * 0.32,y: h))
        path.addLine(to: CGPoint(x: w * 0.32,y: headH))
        path.addLine(to: CGPoint(x: 0,       y: headH))
        path.closeSubpath()
        return path
    }
}

#Preview {
    ArrowView()
        .frame(width: 640, height: 260)
        .background(Color.clear)
        .padding()
}

################################################################################
FILE: ArrowWindow.swift
SIZE: 551 bytes

################################################################################
import SwiftUI

struct ArrowWindow: View {
    let index: Int

    var body: some View {
        ArrowView()
            .padding(16)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))
            .navigationTitle("Стрелка #\(index)")
            .toolbar {
                ToolbarItem(placement: .status) {
                    Text("Окно со стрелкой #\(index)")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
            }
    }
}

################################################################################
FILE: CatalogAPIClient.swift
SIZE: 6177 bytes

################################################################################
import Foundation

struct CatalogAPIClient {
    enum APIError: LocalizedError { case invalidURL, http(Int), decoding(Error) }

    struct Configuration: Sendable {
        let baseV3: URL
        static let production = Configuration(baseV3: URL(string: "https://catalog.api.2gis.com/3.0")!)
    }

    private let apiKey: String
    private let session: URLSession
    private let config: Configuration
    private let decoder: JSONDecoder

    init(apiKey: String, session: URLSession = .shared, config: Configuration = .production) {
        self.apiKey = apiKey
        self.session = session
        self.config = config
        let d = JSONDecoder()
        d.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder = d
    }

    // MARK: Endpoints

    func geocodeBuilding(lon: Double, lat: Double, radius: Int? = 50) async throws -> GeocodeResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items/geocode"), resolvingAgainstBaseURL: false)!
        var qi: [URLQueryItem] = [
            .init(name: "lon", value: String(lon)),
            .init(name: "lat", value: String(lat)),
            .init(name: "type", value: "building"),
            .init(name: "key", value: apiKey)
        ]
        if let radius { qi.append(.init(name: "radius", value: String(radius))) }
        comp.queryItems = qi
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: GeocodeResponse.self)
    }

    func buildingDetails(id: String, fields: String?) async throws -> BuildingDetailsResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items/byid"), resolvingAgainstBaseURL: false)!
        var items = [URLQueryItem(name: "id", value: id), URLQueryItem(name: "key", value: apiKey)]
        if let fields, !fields.isEmpty { items.append(.init(name: "fields", value: fields)) }
        comp.queryItems = items
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: BuildingDetailsResponse.self)
    }

    func listIndoorOrganizations(buildingId: String, page: Int = 1, pageSize: Int = 12) async throws -> PlacesSearchResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items"), resolvingAgainstBaseURL: false)!
        comp.queryItems = [
            .init(name: "key", value: apiKey),
            .init(name: "building_id", value: buildingId),
            .init(name: "search_type", value: "indoor"),
            .init(name: "page", value: String(page)),
            .init(name: "page_size", value: String(pageSize))
        ]
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: PlacesSearchResponse.self)
    }

    func listServicing(buildingId: String, group: String = "default", fields: String? = nil, page: Int = 1, pageSize: Int = 12) async throws -> PlacesSearchResponse {
        var comp = URLComponents(url: URL(string: "https://catalog.api.2gis.com")!.appendingPathComponent("3.0/items/byservicing"), resolvingAgainstBaseURL: false)!
        var items = [
            URLQueryItem(name: "key", value: apiKey),
            URLQueryItem(name: "building_id", value: buildingId),
            URLQueryItem(name: "servicing_group", value: group),
            URLQueryItem(name: "page", value: String(page)),
            URLQueryItem(name: "page_size", value: String(pageSize))
        ]
        if let fields, !fields.isEmpty { items.append(.init(name: "fields", value: fields)) }
        comp.queryItems = items
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: PlacesSearchResponse.self)
    }

    // MARK: Sending
    private func send<T: Decodable>(_ req: URLRequest, decode: T.Type) async throws -> T {
        let (data, resp) = try await session.data(for: req)
        guard let http = resp as? HTTPURLResponse else { throw APIError.invalidURL }
        guard 200..<300 ~= http.statusCode else { throw APIError.http(http.statusCode) }
        do { return try decoder.decode(T.self, from: data) } catch { throw APIError.decoding(error) }
    }
}

// MARK: Models

struct GeocodeResponse: Decodable {
    struct Result: Decodable { let items: [GeocodeItem]?; let total: Int? }
    let meta: Meta?
    let result: Result?
}

struct GeocodeItem: Decodable, Identifiable { let id: String; let name: String; let fullName: String?; let type: String }

struct BuildingDetailsResponse: Decodable {
    struct Result: Decodable { let items: [BuildingDetails]?; let total: Int? }
    let meta: Meta?
    let result: Result?
}

struct BuildingDetails: Decodable, Identifiable {
    struct Point: Decodable { let lon: Double?; let lat: Double? }
    struct StructureInfo: Decodable {
        let material: String?
        let apartmentsCount: Int?
        let porchCount: Int?
        let floorType: String?
        let gasType: String?
        let yearOfConstruction: Int?
        let elevatorsCount: Int?
        let isInEmergencyState: Bool?
        let projectType: String?
        let chsName: String?
        let chsCategory: String?
    }
    let id: String
    let name: String
    let addressName: String?
    let type: String
    let floors: Int?
    let point: Point?
    let structureInfo: StructureInfo?
}

struct Meta: Decodable { let apiVersion: String?; let code: Int?; let issueDate: String? }

struct PlacesSearchResponse: Decodable {
    struct Result: Decodable { let items: [PlaceItem]? }
    let meta: Meta?
    let result: Result?
}

struct PlaceItem: Decodable, Identifiable {
    struct Point: Decodable { let lon: Double?; let lat: Double? }
    struct ContactGroup: Decodable { let name: String?; let contacts: [Contact]?; struct Contact: Decodable { let type: String?; let value: String? } }
    struct WorkingHours: Decodable { let text: String? }
    let id: String
    let name: String?
    let addressName: String?
    let point: Point?
    let rubrics: [Rubric]?
    let contactGroups: [ContactGroup]?
    let workingHours: WorkingHours?
    let links: [String: String]? // keep flexible
    let rating: Double?
    let reviewsCount: Int?
    struct Rubric: Decodable { let name: String? }
}


################################################################################
FILE: CatalogFlowViewModel.swift
SIZE: 4015 bytes

################################################################################
import Foundation
import Observation

@MainActor
@Observable
class CatalogFlowViewModel {
    struct FlowResult: Sendable {
        var building: BuildingDetails?
        var organizations: [PlaceItem]
        var diagnostics: [String]
    }

    private let client: CatalogAPIClient

    var isRunning: Bool = false
    var lastResult: FlowResult?
    var lastError: String?

    init(apiKey: String = "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe") {
        self.client = CatalogAPIClient(apiKey: apiKey)
    }

    func run(lon: Double, lat: Double) async {
        guard !isRunning else { return }
        isRunning = true
        lastError = nil
        var diagnostics: [String] = []

        var buildingId: String?
        var buildingDetails: BuildingDetails?
        var organizations: [PlaceItem] = []

        // 1) Nearest building via geocoder with increasing radius
        do {
            let radii = [10, 50, 150, 300]
            var found: GeocodeItem?
            for r in radii {
                let geo = try await client.geocodeBuilding(lon: lon, lat: lat, radius: r)
                if let item = geo.result?.items?.first {
                    found = item
                    diagnostics.append("geocode: hit radius=\(r)")
                    break
                } else {
                    diagnostics.append("geocode: empty radius=\(r)")
                }
            }
            buildingId = found?.id
        } catch {
            diagnostics.append("geocode error: \(error.localizedDescription)")
        }

        // 2) Building details by id (best-effort)
        if let id = buildingId {
            let fields = "items.address,items.floors,items.structure_info.material,items.structure_info.apartments_count,items.structure_info.porch_count,items.structure_info.floor_type,items.structure_info.year_of_construction,items.structure_info.elevators_count,items.structure_info.gas_type,items.structure_info.project_type,items.structure_info.chs_name,items.structure_info.chs_category"
            do {
                let resp = try await client.buildingDetails(id: id, fields: fields)
                buildingDetails = resp.result?.items?.first
                if buildingDetails == nil { diagnostics.append("details: no items") }
            } catch {
                diagnostics.append("details error: \(error.localizedDescription)")
            }
        } else {
            diagnostics.append("no building id — skipping details & orgs")
        }

        // 3) Organizations inside building (fallback to servicing)
        if let id = buildingId {
            do {
                let resp = try await client.listIndoorOrganizations(buildingId: id, page: 1, pageSize: 12)
                organizations = resp.result?.items ?? []
                if organizations.isEmpty {
                    diagnostics.append("indoor: empty; try byservicing")
                    do {
                        let svc = try await client.listServicing(buildingId: id, group: "default", fields: "items.contact_groups,items.working_hours,items.links")
                        organizations = svc.result?.items ?? []
                    } catch {
                        diagnostics.append("byservicing error: \(error.localizedDescription)")
                    }
                }
            } catch {
                diagnostics.append("indoor error: \(error.localizedDescription)")
                // Try servicing even if indoor failed
                do {
                    let svc = try await client.listServicing(buildingId: id, group: "default", fields: "items.contact_groups,items.working_hours,items.links")
                    organizations = svc.result?.items ?? []
                } catch {
                    diagnostics.append("byservicing error: \(error.localizedDescription)")
                }
            }
        }

        self.lastResult = FlowResult(building: buildingDetails, organizations: organizations, diagnostics: diagnostics)
        isRunning = false
    }
}


################################################################################
FILE: ContentView.swift
SIZE: 17899 bytes

################################################################################
//
//  ContentView.swift
//  2gis
//
//  Created by Павел on 04.10.2025.
//

import SwiftUI
import RealityKit
import Observation

struct ContentView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.openWindow) private var openWindow

    @State private var navigationViewModel = NavigationViewModel()
    @State private var catalogViewModel = CatalogFlowViewModel()
    
    @State private var destPoint: RoutePoint = RoutePoint(lon: 0, lat: 0, type: RoutePoint.PointType.stop)
    @State private var destinationPlaceText: String = ""
    
    @State private var lonText: String = "37.625325"
    @State private var latText: String = "55.695281"

    // NEW:
    @State private var locationService = LocationService()

    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
            // Выбор сцены
            // ScenePickerView(appModel: appModel)

            // Текущие GPS-координаты
            gpsBlock

            Divider()

            // Демонстрация Navigation API
                NavigationDemoView(viewModel: navigationViewModel, addrText: $destinationPlaceText, locationService: $locationService, destPoint: $destPoint)

            Divider()

            // Каталог по координатам
            CatalogFlowSection(viewModel: catalogViewModel, lonText: $lonText, latText: $latText)
            }
            .padding(24)
        }
        .onAppear {
            locationService.distanceThresholdMeters = 1.0
            locationService.start()
            if appModel.selectedScene == .arrow && !appModel.hasOpenedArrowWindowOnce {
                openWindow(id: "ArrowWindow1")
                openWindow(id: "ArrowWindow2")
                openWindow(id: "ArrowWindow3")
                appModel.hasOpenedArrowWindowOnce = true
            }
//            Task { await updateImmersiveSpace(for: appModel.selectedScene) }
        }
        .onChange(of: locationService.currentLocation) { _, newLoc in
            guard let loc = newLoc else { return }
            lonText = String(format: "%.6f", loc.coordinate.longitude)
            latText = String(format: "%.6f", loc.coordinate.latitude)
    
            if locationService.checkAndSnapIfNeeded() {
                Task {
                    await catalogViewModel.run(lon: loc.coordinate.longitude, lat: loc.coordinate.latitude)
                }
            }
        }
        // ✅ Изменение сцены: открыть окна стрелок и синхронизировать Immersive
        .onChange(of: appModel.selectedScene) { _, newSelection in
            Task {
                if newSelection == .arrow && !appModel.hasOpenedArrowWindowOnce {
                    openWindow(id: "ArrowWindow1")
                    openWindow(id: "ArrowWindow2")
                    openWindow(id: "ArrowWindow3")
                    appModel.hasOpenedArrowWindowOnce = true
                }
//                await updateImmersiveSpace(for: newSelection)
            }
        }
    }


    private var gpsBlock: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("GPS")
                .font(.title3).bold()
            switch locationService.status {
            case .authorized:
                if let loc = locationService.currentLocation {
                    Text(String(format: "Lat: %.6f, Lon: %.6f (±%.0f м)",
                                loc.coordinate.latitude,
                                loc.coordinate.longitude,
                                loc.horizontalAccuracy))
                        .font(.callout)
                        .foregroundStyle(.secondary)
                } else {
                    Text("Ожидание данных…").foregroundStyle(.secondary)
                }
            case .requesting:
                Text("Запрашиваем разрешение…").foregroundStyle(.secondary)
            case .denied:
                Text("Доступ к геолокации запрещён. Разрешите доступ в настройках.")
                    .foregroundStyle(.red)
            case .restricted:
                Text("Геолокация недоступна (ограничения системы).")
                    .foregroundStyle(.red)
            case .idle:
                Text("Инициализация сервиса…").foregroundStyle(.secondary)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 12))
    }

    // @MainActor
    // private func updateImmersiveSpace(for selection: AppModel.SceneSelection) async {
    //     // 🚫 Если сейчас меню — не пытаемся открывать Immersive
    //     guard appModel.uiMode == .immersive else { return }

    //     switch appModel.immersiveSpaceState {
    //     case .closed:
    //         appModel.immersiveSpaceState = .inTransition
    //         let result = await openImmersiveSpace(id: appModel.immersiveSpaceID)
    //         switch result {
    //         case .opened: break
    //         case .userCancelled, .error: appModel.immersiveSpaceState = .closed
    //         @unknown default: appModel.immersiveSpaceState = .closed
    //         }
    //     case .open, .inTransition:
    //         break
    //     }
    // }
}

private struct ScenePickerView: View {
    @Bindable var appModel: AppModel

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Выбор сцены")
                .font(.headline)

            Picker("Сцена", selection: $appModel.selectedScene) {
                Text("Плоская стрелка").tag(AppModel.SceneSelection.arrow)
                Text("3D куб").tag(AppModel.SceneSelection.cube)
            }
            .pickerStyle(.segmented)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

private struct ScenePreview: View {
    let selection: AppModel.SceneSelection
    @Environment(\.openWindow) private var openWindow

    var body: some View {
        switch selection {
        case .arrow:
            VStack(alignment: .leading, spacing: 12) {
                Label("Окна со стрелкой", systemImage: "rectangle.on.rectangle")
                    .font(.headline)
                Text("Три окна со стрелкой открываются автоматически. В иммерсивной сцене показаны три стрелки с шагом 1 м по глубине.")
                    .font(.callout)
                    .foregroundStyle(.secondary)
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))

        case .cube:
            VStack(alignment: .leading, spacing: 12) {
                Image(systemName: "cube")
                    .font(.largeTitle)
                Text("Куб отображается в иммерсивной сцене перед вами. Перемещайтесь свободно — объект остаётся закреплённым в пространстве.")
                    .font(.callout)
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))
        }
    }
}

private struct NavigationDemoView: View {
    @Bindable var viewModel: NavigationViewModel
    @Binding var addrText: String
    @Binding var locationService: LocationService
    @Binding var destPoint: RoutePoint

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("2GIS Navigation APIs")
                .font(.title2)
                .bold()

            TextField("addr", text: $addrText)
                .textFieldStyle(.roundedBorder)
                .keyboardType(.numbersAndPunctuation)
            
            Button(action: savePointFromAddr) {
                Label("Найти адрессс", systemImage: "house")
            }
            

            HStack {
                Button(action: loadRoute) {
                    Label("Построить маршрут", systemImage: "car")
                }
                .disabled(viewModel.isLoading)

                // Button(action: loadMapMatch) {
                //     Label("Map matching", systemImage: "map")
                // }
                // .disabled(viewModel.isLoading)

                // Button(action: loadGeolocation) {
                //     Label("Radar геолокация", systemImage: "location.north.line")
                // }
                // .disabled(viewModel.isLoading)
            }
            .buttonStyle(.borderedProminent)

            if viewModel.isLoading {
                ProgressView()
            }

            if let error = viewModel.errorMessage {
                Text(error)
                    .foregroundStyle(Color.red)
            }

            if let route = viewModel.lastRouteResponse?.result?.first {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Маршрут: \(route.id ?? "неизвестно")")
                        .font(.headline)
                    if let algorithm = route.algorithm {
                        Text("Алгоритм: \(algorithm)")
                            .font(.subheadline)
                    }
                    if let maneuvers = route.maneuvers {
                        Text("Манёвры")
                            .font(.subheadline)
                            .bold()
                        ForEach(Array(maneuvers.prefix(3).enumerated()), id: \.offset) { index, maneuver in
                            Text("\(index + 1). \(maneuver.comment ?? "—")")
                                .font(.footnote)
                        }
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
                .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
            }

            // if let mapMatch = viewModel.lastMapMatchResponse {
            //     VStack(alignment: .leading, spacing: 8) {
            //         Text("Map matching")
            //             .font(.headline)
            //         if let distance = mapMatch.distance {
            //             Text(String(format: "Длина: %.0f м", distance))
            //         }
            //         if let duration = mapMatch.duration {
            //             Text(String(format: "Время: %.0f с", duration))
            //         }
            //         if let status = mapMatch.status {
            //             Text("Статус: \(status)")
            //                 .font(.footnote)
            //         }
            //     }
            //     .frame(maxWidth: .infinity, alignment: .leading)
            //     .padding()
            //     .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
            // }

            // if let location = viewModel.lastGeolocationResponse?.location {
            //     VStack(alignment: .leading, spacing: 8) {
            //         Text("Геолокация Radar")
            //             .font(.headline)
            //         if let latitude = location.latitude, let longitude = location.longitude {
            //             Text(String(format: "Lat: %.5f, Lon: %.5f", latitude, longitude))
            //         }
            //         if let accuracy = location.accuracy {
            //             Text(String(format: "Точность: %.0f м", accuracy))
            //         }
            //     }
            //     .frame(maxWidth: .infinity, alignment: .leading)
            //     .padding()
            //     .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
            // }
        }
    }
    
    private func savePointFromAddr() {
        Task { 
            do {
                let client = DGisPlacesClient(
                    config: DGisPlacesClient.Config(apiKey: "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe")
                )

                // bestMatch бросит ошибку, если ничего не найдено
                let best = try await client.bestMatch(self.addrText)

                // безопасно распакуем координаты
                guard let p = best.point,
                      let lon = p.lon,
                      let lat = p.lat else {
                    return
                }

                // обновляем UI на главном потоке
                await MainActor.run {
                    self.addrText = best.addressName ?? best.name

                    // ВАРИАНТ 1: если у тебя инициализатор помеченный:
                    self.destPoint = RoutePoint(lon: best.point!.lon!, lat: best.point!.lat!, type:RoutePoint.PointType.stop)

                    // ВАРИАНТ 2: если требуется ещё type:
                    // self.destPoint = RoutePoint(lon: lon, lat: lat, type: .pref)

                    // ВАРИАНТ 3: если у тебя позиционный init:
                    // self.destPoint = RoutePoint(lon, lat)
                }
            } catch {
                // обработай/залогуй ошибку
                print("Search failed:", error)
            }
        }
    }


    private func loadRoute() {
        Task { await viewModel.loadSampleRoute(locationService: locationService, destinationPoint:destPoint) }
    }

    private func loadMapMatch() {
        Task { await viewModel.loadSampleMapMatch() }
    }

    private func loadGeolocation() {
        Task { await viewModel.loadSampleGeolocation() }
    }
}

private struct CatalogFlowSection: View {
    @Bindable var viewModel: CatalogFlowViewModel
    @Binding var lonText: String
    @Binding var latText: String

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Здание и организации по координате")
                .font(.title3)
                .bold()

            HStack(spacing: 12) {
                TextField("lon", text: $lonText)
                    .textFieldStyle(.roundedBorder)
                    .keyboardType(.numbersAndPunctuation)
                TextField("lat", text: $latText)
                    .textFieldStyle(.roundedBorder)
                    .keyboardType(.numbersAndPunctuation)
                Button {
                    Task {
                        if let lon = Double(lonText), let lat = Double(latText) {
                            await viewModel.run(lon: lon, lat: lat)
                        }
                    }
                } label: {
                    Label("Найти", systemImage: "building.2")
                }
                .disabled(viewModel.isRunning)
            }

            if viewModel.isRunning { ProgressView() }

            if let result = viewModel.lastResult {
                if let b = result.building {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(b.name).font(.headline)
                        if let addr = b.addressName { Text(addr).font(.subheadline) }
                        HStack(spacing: 8) {
                            if let floors = b.floors { Text("Этажей: \(floors)") }
                            if let material = b.structureInfo?.material { Text("Материал: \(material)") }
                            if let year = b.structureInfo?.yearOfConstruction { Text("Год: \(year)") }
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding()
                    .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
                } else {
                    Text("Здание не найдено рядом с точкой").foregroundStyle(.secondary)
                }

                if !result.organizations.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Организации внутри")
                            .font(.headline)
                        ForEach(result.organizations, id: \.id) { org in
                            VStack(alignment: .leading, spacing: 2) {
                                Text(org.name ?? "—").font(.subheadline).bold()
                                if let addr = org.addressName { Text(addr).font(.footnote).foregroundStyle(.secondary) }
                                if let rub = org.rubrics?.compactMap({ $0.name }).first { Text(rub).font(.footnote) }
                            }
                            .padding(8)
                            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 10))
                        }
                    }
                } else {
                    Text("Организации не найдены").foregroundStyle(.secondary)
                }

                if !result.diagnostics.isEmpty {
                    Text(result.diagnostics.joined(separator: " · "))
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
            }
        }
    }
}

#Preview(windowStyle: .automatic) {
    ContentView()
        .environment(AppModel())
}

################################################################################
FILE: ImmersiveView.swift
SIZE: 4587 bytes

################################################################################
//
//  ImmersiveView.swift
//  2gis
//
//  Created by Павел on 04.10.2025.
//

import SwiftUI
import RealityKit

struct ImmersiveView: View {
    @Environment(AppModel.self) var appModel

    var body: some View {
        RealityView { content in
            // ---------- HEAD (стрелка) ----------
            let headAnchor = AnchorEntity(.head)
            headAnchor.name = "HeadAnchor"

            // Плоская плашка-стрелка, смотрит на пользователя (три экземпляра с шагом 1 м)
            let arrowSize: SIMD2<Float> = [0.40, 0.18]
            let mesh = MeshResource.generatePlane(width: arrowSize.x, height: arrowSize.y, cornerRadius: 0.03)

            func makeArrow(name: String, color: UIColor) -> ModelEntity {
                var mat = UnlitMaterial()
                mat.color = .init(tint: color)
                let e = ModelEntity(mesh: mesh, materials: [mat])
                e.name = name
                e.components.set(BillboardComponent())
                return e
            }

            let arrow1 = makeArrow(name: "ArrowBillboard1", color: .init(red: 0.0, green: 0.7, blue: 1.0, alpha: 1.0))
            let arrow2 = makeArrow(name: "ArrowBillboard2", color: .init(red: 0.1, green: 0.9, blue: 0.6, alpha: 1.0))
            let arrow3 = makeArrow(name: "ArrowBillboard3", color: .init(red: 1.0, green: 0.5, blue: 0.2, alpha: 1.0))

            let d0 = max(1.0 as Float, min(5.0 as Float, appModel.arrowDistance))
            arrow1.position = [0.0, 0.0, -d0]
            arrow2.position = [0.0, 0.0, -(d0 + 1.0)]
            arrow3.position = [0.0, 0.0, -(d0 + 2.0)]

            headAnchor.addChild(arrow1)
            headAnchor.addChild(arrow2)
            headAnchor.addChild(arrow3)
            headAnchor.isEnabled = (appModel.selectedScene == .arrow)
            content.add(headAnchor)

            // ---------- WORLD (куб) ----------
            let worldAnchor = AnchorEntity(world: SIMD3<Float>(0, 1.4, -1.5))
            worldAnchor.name = "WorldAnchorCube"

            let cube = ModelEntity(mesh: .generateBox(size: 0.45, cornerRadius: 0.06))
            cube.model?.materials = [
                SimpleMaterial(color: .init(red: 0.15, green: 0.55, blue: 0.95, alpha: 1.0),
                               roughness: 0.25, isMetallic: true)
            ]
            cube.transform.rotation = simd_quatf(angle: .pi / 6, axis: SIMD3<Float>(1, 1, 0))
            worldAnchor.addChild(cube)

            let key = DirectionalLight()
            key.light.color = .init(red: 1.0, green: 0.95, blue: 0.9, alpha: 1.0)
            key.light.intensity = 2_000
            key.shadow = DirectionalLightComponent.Shadow(maximumDistance: 10, depthBias: 0.02)
            key.look(at: .zero, from: [1.5, 1.5, 1.0], relativeTo: worldAnchor)
            worldAnchor.addChild(key)

            let fill = DirectionalLight()
            fill.light.color = .init(white: 0.8, alpha: 1.0)
            fill.light.intensity = 600
            fill.look(at: .zero, from: [-1.0, 0.8, -0.5], relativeTo: worldAnchor)
            worldAnchor.addChild(fill)

            worldAnchor.isEnabled = (appModel.selectedScene == .cube)
            content.add(worldAnchor)

        } update: { content in
            // Обновляем дистанцию стрелок (всегда 1…5 м), с интервалом 1 м
            let d = max(1.0 as Float, min(5.0 as Float, appModel.arrowDistance))
            if let a1 = content.entities.first(where: { $0.name == "ArrowBillboard1" }) as? ModelEntity {
                a1.position = [0, 0, -d]
            }
            if let a2 = content.entities.first(where: { $0.name == "ArrowBillboard2" }) as? ModelEntity {
                a2.position = [0, 0, -(d + 1.0)]
            }
            if let a3 = content.entities.first(where: { $0.name == "ArrowBillboard3" }) as? ModelEntity {
                a3.position = [0, 0, -(d + 2.0)]
            }
            // Переключаем сцены без пересоздания
            if let headAnchor = content.entities.first(where: { $0.name == "HeadAnchor" }) {
                headAnchor.isEnabled = (appModel.selectedScene == .arrow)
            }
            if let worldAnchor = content.entities.first(where: { $0.name == "WorldAnchorCube" }) {
                worldAnchor.isEnabled = (appModel.selectedScene == .cube)
            }
        }
        .onAppear { appModel.immersiveSpaceState = .open }
        .onDisappear { appModel.immersiveSpaceState = .closed }
    }
}


################################################################################
FILE: LocationService.swift
SIZE: 3581 bytes

################################################################################
import Foundation
import CoreLocation
import Observation

@MainActor
@Observable
final class LocationService: NSObject {
    enum Status {
        case idle, requesting, authorized, denied, restricted
    }

    private let manager = CLLocationManager()

    // Публичные данные
    var status: Status = .idle
    var currentLocation: CLLocation?
    var lastMeterSnapLocation: CLLocation?

    // Настройки
    var distanceThresholdMeters: CLLocationDistance = 1.0   // «каждый метр»
    var desiredAccuracy: CLLocationAccuracy = kCLLocationAccuracyBest

    override init() {
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = desiredAccuracy
        manager.distanceFilter = kCLDistanceFilterNone // пусть отдаёт максимально часто, фильтруем сами
        manager.activityType = .fitness                // пешеходный кейс; можно .otherNavigation
        manager.pausesLocationUpdatesAutomatically = true
    }

    func requestAuthorizationIfNeeded() {
        switch manager.authorizationStatus {
        case .notDetermined:
            status = .requesting
            manager.requestWhenInUseAuthorization()
        case .authorizedAlways, .authorizedWhenInUse:
            status = .authorized
        case .denied:
            status = .denied
        case .restricted:
            status = .restricted
        @unknown default:
            status = .restricted
        }
    }

    func start() {
        requestAuthorizationIfNeeded()
        if case .authorized = status {
            manager.startUpdatingLocation()
        }
    }

    func stop() {
        manager.stopUpdatingLocation()
    }

    /// Возвращает true, если от последней «защёлкнутой» точки пройдено >= threshold
    @discardableResult
    func checkAndSnapIfNeeded(threshold: CLLocationDistance? = nil) -> Bool {
        guard let loc = currentLocation else { return false }
        let thr = threshold ?? distanceThresholdMeters
        if let last = lastMeterSnapLocation {
            if loc.distance(from: last) >= thr {
                lastMeterSnapLocation = loc
                return true
            }
            return false
        } else {
            lastMeterSnapLocation = loc
            return true
        }
    }
}

extension LocationService: CLLocationManagerDelegate {
    nonisolated func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        Task { @MainActor in
            switch manager.authorizationStatus {
            case .authorizedAlways, .authorizedWhenInUse:
                status = .authorized
                self.manager.startUpdatingLocation()
            case .denied:
                status = .denied
            case .restricted:
                status = .restricted
            case .notDetermined:
                status = .requesting
            @unknown default:
                status = .restricted
            }
        }
    }

    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let latest = locations.last else { return }
        Task { @MainActor in
            currentLocation = latest
        }
    }

    nonisolated func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        // Можно логировать/показывать пользователю
        // print("Location error:", error.localizedDescription)
    }
}

################################################################################
FILE: NavigationAPIClient.swift
SIZE: 11756 bytes

################################################################################
import Foundation
import CoreLocation

// MARK: - Navigation API Client

/// Lightweight client for 2GIS navigation-related APIs (Routing, Map Matching, Radar).
struct NavigationAPIClient {

    // MARK: Configuration

    struct Configuration: Sendable {
        let routingBaseURL: URL
        let radarBaseURL: URL

        static let production = Configuration(
            routingBaseURL: URL(string: "https://routing.api.2gis.com")!,
            radarBaseURL: URL(string: "https://radar.api.2gis.com")!
        )
    }

    // MARK: Errors

    enum APIError: LocalizedError {
        case invalidURL
        case httpError(statusCode: Int, body: Data)
        case decoding(DecodingError)          // конкретно DecodingError (чтобы видеть, что именно не так)
        case decodingOther(Error)             // на случай другой ошибки при decode()

        var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "Не удалось собрать URL для запроса."
            case let .httpError(statusCode, _):
                return "Сервер вернул статус-код \(statusCode)."
            case let .decoding(err):
                return "Ошибка декодирования ответа: \(err)"
            case let .decodingOther(err):
                return "Ошибка при обработке ответа: \(err.localizedDescription)"
            }
        }
    }

    // MARK: Core

    private let apiKey: String
    private let session: URLSession
    private let configuration: Configuration
    private let encoder: JSONEncoder
    private let decoder: JSONDecoder

    init(
        apiKey: String,
        session: URLSession = .shared,
        configuration: Configuration = .production
    ) {
        self.apiKey = apiKey
        self.session = session
        self.configuration = configuration

        let enc = JSONEncoder()
        enc.keyEncodingStrategy = .convertToSnakeCase
        enc.dateEncodingStrategy = .secondsSince1970
        self.encoder = enc

        let dec = JSONDecoder()
        dec.keyDecodingStrategy = .convertFromSnakeCase
        dec.dateDecodingStrategy = .secondsSince1970
        self.decoder = dec
    }
}

// MARK: - Public API

extension NavigationAPIClient {

    /// POST /routing/7.0.0/global?key=...
    func buildRoute(_ request: RouteRequest) async throws -> RouteResponse {
        let url = try url(base: configuration.routingBaseURL, pathComponents: ["routing", "7.0.0", "global"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: RouteResponse.self)
    }

    /// POST /map_matching/1.0.0?key=...
    func mapMatch(_ request: MapMatchRequest) async throws -> MapMatchResponse {
        let url = try url(base: configuration.routingBaseURL, pathComponents: ["map_matching", "1.0.0"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: MapMatchResponse.self)
    }

    /// POST /v2/geolocation?key=...
    func geolocate(_ request: GeolocationRequest) async throws -> GeolocationResponse {
        let url = try url(base: configuration.radarBaseURL, pathComponents: ["v2", "geolocation"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: GeolocationResponse.self)
    }
}

// MARK: - Request helpers

private extension NavigationAPIClient {

    /// Собирает URL из базового домена + path components, добавляет `key` как query item.
    func url(base: URL, pathComponents: [String], key: String) throws -> URL {
        var url = base
        for p in pathComponents {
            url.appendPathComponent(p)
        }
        guard var comps = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
            throw APIError.invalidURL
        }
        var q: [URLQueryItem] = comps.queryItems ?? []
        q.append(URLQueryItem(name: "key", value: key))
        comps.queryItems = q
        guard let final = comps.url else { throw APIError.invalidURL }
        return final
    }

    func send<Response: Decodable>(_ request: URLRequest, decode type: Response.Type) async throws -> Response {
        #if DEBUG
        debugPrint("➡️ \(request.httpMethod ?? "GET") \(request.url?.absoluteString ?? "")")
        if let body = request.httpBody, let s = String(data: body, encoding: .utf8) {
            debugPrint("➡️ Body:\n\(s)")
        }
        #endif

        let (data, response) = try await session.data(for: request)

        guard let http = response as? HTTPURLResponse else {
            throw APIError.invalidURL
        }

        #if DEBUG
        debugPrint("⬅️ Status: \(http.statusCode)")
        if let s = String(data: data, encoding: .utf8) {
            debugPrint("⬅️ Raw JSON (\(data.count) bytes):\n\(s)")
        }
        #endif

        guard (200..<300).contains(http.statusCode) else {
            throw APIError.httpError(statusCode: http.statusCode, body: data)
        }

        do {
            return try decoder.decode(Response.self, from: data)
        } catch let decErr as DecodingError {
            throw APIError.decoding(decErr)
        } catch {
            throw APIError.decodingOther(error)
        }
    }
}

// MARK: - Routing models

struct RouteRequest: Encodable {
    enum Output: String, Codable { case summary, detailed }

    var points: [RoutePoint]
    var transport: String?           // "driving", "walking", "bicycle", "scooter", "motorcycle", "truck", "taxi"
    var filters: [String]?           // e.g. ["dirt_road","toll_road","ferry"]
    var output: Output?              // summary | detailed (default detailed)
    var locale: String?              // "en", "ru", ...
    var avoid: [String]?             // area/road types to avoid

    init(
        points: [RoutePoint],
        transport: String? = nil,
        filters: [String]? = nil,
        output: Output? = .detailed,
        locale: String? = nil,
        avoid: [String]? = nil
    ) {
        self.points = points
        self.transport = transport
        self.filters = filters
        self.output = output
        self.locale = locale
        self.avoid = avoid
    }
}

struct RoutePoint: Codable {
    enum PointType: String, Codable { case walking, stop, pref }
    var lon: Double
    var lat: Double
    var type: PointType
    var start: Bool?

    init(lon: Double, lat: Double, type: PointType, start: Bool? = nil) {
        self.lon = lon
        self.lat = lat
        self.type = type
        self.start = start
    }
}

struct RouteResponse: Decodable {
    let message: String?
    let query: [String: JSONValue]?   // сервер может эхо-возвращать запрос
    let result: [RouteResult]?        // делаем optional: иногда сервис возвращает только message
}

struct RouteResult: Decodable {
    let algorithm: String?
    let id: String?
    let maneuvers: [Maneuver]?
    let filterRoadTypes: [String]?
}

struct Maneuver: Decodable {
    let id: String?
    let comment: String?
    let icon: String?
    let outcomingPath: Segment?
    let outcomingPathComment: String?

    struct Segment: Decodable {
        let distance: Double?
        let duration: Double?
        let geometry: [SegmentGeometry]?
    }
}

struct SegmentGeometry: Decodable, Identifiable {
    let id = UUID()
    let color: String?
    let length: Double?
    let selection: String?   // WKT LINESTRING
    let style: String?

    private enum CodingKeys: String, CodingKey { case color, length, selection, style }
}

// MARK: - Map matching models

struct MapMatchRequest: Encodable {
    var query: [RecordedPoint]

    init(query: [RecordedPoint]) {
        self.query = query
    }
}

struct RecordedPoint: Codable {
    var lon: Double
    var lat: Double
    var utc: Int
    var speed: Double?
    var azimuth: Double?

    init(lon: Double, lat: Double, utc: Int, speed: Double? = nil, azimuth: Double? = nil) {
        self.lon = lon
        self.lat = lat
        self.utc = utc
        self.speed = speed
        self.azimuth = azimuth
    }
}

struct MapMatchResponse: Decodable {
    let distance: Double?
    let duration: Double?
    let edges: [MatchedEdge]?
    let query: [MatchedQueryPoint]?
    let route: String?
    let status: String?
}

struct MatchedEdge: Decodable, Identifiable {
    let edgeId: Int
    let distance: Double?
    let geometry: String?

    var id: Int { edgeId }
}

struct MatchedQueryPoint: Decodable, Identifiable {
    let utc: Int
    let lon: Double?
    let lat: Double?
    let lonMatched: Double?
    let latMatched: Double?
    let edgeId: Int?
    let speed: Double?
    let azimuth: Double?

    var id: Int { utc }
}

// MARK: - Radar geolocation models

struct GeolocationRequest: Encodable {
    var sessionUUID: String
    var captureTimestampUnix: Int
    var gnssLocation: GnssLocation?
    var mobileNetwork: MobileNetwork?
    var wifiAccessPoints: [WifiAccessPoint]?

    struct GnssLocation: Codable {
        var latitude: Double
        var longitude: Double
        var horizontalAccuracyM: Double?
    }

    struct MobileNetwork: Codable {
        var homeMobileCountryCode: Int
        var homeMobileNetworkCode: Int
        var cellTowers: [CellTower]
    }

    struct CellTower: Codable {
        var cellID: Int
        var networkType: String
        var locationAreaCode: Int
        var signalStrengthDBm: Int?
        var ageMs: Int?
    }

    struct WifiAccessPoint: Codable {
        var macAddress: String
        var signalStrengthDBm: Int?
        var ageMs: Int?
    }
}

struct GeolocationResponse: Decodable {
    let statusCode: Int?
    let state: String?
    let location: Location?

    struct Location: Decodable {
        let longitude: Double?
        let latitude: Double?
        let accuracy: Double?
    }
}

// MARK: - JSONValue (для произвольных кусочков JSON)

/// Универсальный JSON узел (null/bool/number/string/array/object)
enum JSONValue: Decodable {
    case null
    case bool(Bool)
    case number(Double)
    case string(String)
    case array([JSONValue])
    case object([String: JSONValue])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if container.decodeNil() { self = .null; return }
        if let b = try? container.decode(Bool.self) { self = .bool(b); return }
        if let d = try? container.decode(Double.self) { self = .number(d); return }
        if let s = try? container.decode(String.self) { self = .string(s); return }
        if let arr = try? container.decode([JSONValue].self) { self = .array(arr); return }
        if let obj = try? container.decode([String: JSONValue].self) { self = .object(obj); return }
        throw DecodingError.dataCorruptedError(in: container, debugDescription: "Unsupported JSON type")
    }
}

################################################################################
FILE: NavigationViewModel.swift
SIZE: 3506 bytes

################################################################################
import Foundation
import Observation

@MainActor
@Observable
class NavigationViewModel {
    private let client: NavigationAPIClient

    var isLoading: Bool = false
    var lastRouteResponse: RouteResponse?
    var lastMapMatchResponse: MapMatchResponse?
    var lastGeolocationResponse: GeolocationResponse?
    var errorMessage: String?

    init(client: NavigationAPIClient = NavigationAPIClient(apiKey: "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe")) {
        self.client = client
    }

    func loadSampleRoute(locationService: LocationService, destinationPoint: RoutePoint) async {
        await execute {
            let currentLocation = locationService.currentLocation;
            
            
            if (currentLocation == nil) {
                debugPrint("Use mock instead")
            }
            
            let request = RouteRequest(
                points: [
                    RoutePoint(lon: currentLocation?.coordinate.longitude ?? 104.798401, lat: currentLocation?.coordinate.latitude ?? 51.877124, type: .stop),
                    destinationPoint
                ],
                transport: "walking",
                output: .detailed,
                locale: "ru"
            )
            lastRouteResponse = try await client.buildRoute(request)
        }
    }

    func loadSampleMapMatch() async {
        await execute {
            let baseTimestamp = Int(Date().timeIntervalSince1970) - 120
            let request = MapMatchRequest(
                query: [
                    RecordedPoint(lon: 37.582591, lat: 55.775364, utc: baseTimestamp, speed: 5.0, azimuth: 95),
                    RecordedPoint(lon: 37.610000, lat: 55.772300, utc: baseTimestamp + 30, speed: 6.2, azimuth: 110),
                    RecordedPoint(lon: 37.633200, lat: 55.769500, utc: baseTimestamp + 60, speed: 6.8, azimuth: 115),
                    RecordedPoint(lon: 37.656625, lat: 55.765036, utc: baseTimestamp + 90, speed: 5.4, azimuth: 118)
                ]
            )
            lastMapMatchResponse = try await client.mapMatch(request)
        }
    }

    func loadSampleGeolocation() async {
        await execute {
            let request = GeolocationRequest(
                sessionUUID: UUID().uuidString,
                captureTimestampUnix: Int(Date().timeIntervalSince1970),
                gnssLocation: .init(latitude: 55.770200, longitude: 37.620500, horizontalAccuracyM: 50),
                mobileNetwork: .init(
                    homeMobileCountryCode: 250,
                    homeMobileNetworkCode: 99,
                    cellTowers: [
                        .init(cellID: 42012345, networkType: "lte", locationAreaCode: 41001, signalStrengthDBm: -65, ageMs: 500)
                    ]
                ),
                wifiAccessPoints: [
                    .init(macAddress: "00:11:22:33:44:55", signalStrengthDBm: -45, ageMs: 300),
                    .init(macAddress: "66:77:88:99:AA:BB", signalStrengthDBm: -60, ageMs: 200)
                ]
            )
            lastGeolocationResponse = try await client.geolocate(request)
        }
    }

    private func execute(_ operation: @Sendable @MainActor () async throws -> Void) async {
        guard !isLoading else { return }
        isLoading = true
        errorMessage = nil
        do {
            try await operation()
        } catch {
            errorMessage = (error as? LocalizedError)?.errorDescription ?? error.localizedDescription
        }
        isLoading = false
    }
}

################################################################################
FILE: PlacesClient.swift
SIZE: 5475 bytes

################################################################################
//
//  PlacesClient.swift
//  2gis
//
//  Created by Павел on 05.10.2025.
//

import Foundation

public struct DGisPlacesClient {
    public struct Config {
        public var apiKey: String
        public var baseURL: URL
        public init(apiKey: String,
                    baseURL: URL = URL(string: "https://catalog.api.2gis.com/3.0")!) {
            self.apiKey = apiKey
            self.baseURL = baseURL
        }
    }

    public enum ClientError: Error, LocalizedError {
        case invalidURL
        case http(Int)
        case emptyResult
        public var errorDescription: String? {
            switch self {
            case .invalidURL: return "Invalid URL"
            case .http(let code): return "HTTP error \(code)"
            case .emptyResult: return "No items found"
            }
        }
    }

    public struct Point: Decodable {
        public let lon: Double?
        public let lat: Double?
    }

    public struct PlaceItem: Decodable {
        public let id: String
        public let name: String
        public let addressName: String?
        public let point: Point?

        private enum CodingKeys: String, CodingKey {
            case id, name, point
            case addressName = "address_name"
        }
    }

    public struct Meta: Decodable {
        public let code: Int?
        public let total: Int?
        public let page: Int?
        public let pageSize: Int?

        private enum CodingKeys: String, CodingKey {
            case code, total, page
            case pageSize = "page_size"
        }
    }

    public struct PlacesResultBlock: Decodable {
        public let items: [PlaceItem]?
    }

    public struct PlacesResponse: Decodable {
        public let meta: Meta?
        public let result: PlacesResultBlock?
    }

    private let config: Config
    private let session: URLSession

    public init(config: Config, session: URLSession = .shared) {
        self.config = config
        self.session = session
    }

    /// Поиск мест по названию. Рекомендуется указывать город в тексте запроса (например, "Moscow cafe") для более точного результата. 2GIS также поддерживает пагинацию `page`/`page_size` и список полей `fields`.
    /// Документация: /3.0/items?q=...&key=... (+ page, page_size, fields)
    /// - Parameters:
    ///   - name: Текст запроса (например, "Coffee Like" или "Moscow cafe").
    ///   - cityHint: Необязательная подсказка города; будет добавлена к запросу (см. рекомендации 2GIS).
    ///   - page: Номер страницы (по умолчанию 1).
    ///   - pageSize: Размер страницы (1...50).
    ///   - fields: Дополнительные поля, например: ["items.point","items.address_name"].
    /// - Returns: Распарсенный ответ с метаданными и списком найденных объектов.
    public func searchPlacesByName(
        _ name: String,
        cityHint: String? = nil,
        page: Int = 1,
        pageSize: Int = 12,
        fields: [String] = ["items.point","items.address_name"]
    ) async throws -> PlacesResponse {
        // Сборка q с учётом cityHint (по рекомендации 2GIS добавлять город в текст запроса).
        // См. пример: `q=Moscow cafe&type=branch&key=...`
        let q: String = {
            if let city = cityHint?.trimmingCharacters(in: .whitespacesAndNewlines), !city.isEmpty {
                return "\(city) \(name)"
            } else {
                return name
            }
        }()

        var comps = URLComponents(url: config.baseURL.appendingPathComponent("items"), resolvingAgainstBaseURL: false)
        comps?.queryItems = [
            URLQueryItem(name: "q", value: q),
            URLQueryItem(name: "page", value: String(page)),
            URLQueryItem(name: "page_size", value: String(pageSize)),
            URLQueryItem(name: "key", value: config.apiKey)
        ]

        if !fields.isEmpty {
            comps?.queryItems?.append(URLQueryItem(name: "fields", value: fields.joined(separator: ",")))
        }

        guard let url = comps?.url else { throw ClientError.invalidURL }

        var req = URLRequest(url: url)
        req.httpMethod = "GET"

        let (data, resp) = try await session.data(for: req)
        if let http = resp as? HTTPURLResponse, !(200...299).contains(http.statusCode) {
            throw ClientError.http(http.statusCode)
        }

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .useDefaultKeys

        let dto = try decoder.decode(PlacesResponse.self, from: data)
        return dto
    }

    /// Удобный хелпер: вернуть лучший (первый) матч, иначе ошибка.
    public func bestMatch(
        _ name: String,
        cityHint: String? = nil,
        fields: [String] = ["items.point","items.address_name"]
    ) async throws -> PlaceItem {
        let response = try await searchPlacesByName(name, cityHint: cityHint, page: 1, pageSize: 1, fields: fields)
        if let first = response.result?.items?.first {
            return first
        } else {
            throw ClientError.emptyResult
        }
    }
}

################################################################################
FILE: ToggleImmersiveSpaceButton.swift
SIZE: 2365 bytes

################################################################################
//
//  ToggleImmersiveSpaceButton.swift
//  2gis
//
//  Created by Павел on 04.10.2025.
//

import SwiftUI

struct ToggleImmersiveSpaceButton: View {

    @Environment(AppModel.self) private var appModel

    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace

    var body: some View {
        Button {
            Task { @MainActor in
                switch appModel.immersiveSpaceState {
                    case .open:
                        appModel.immersiveSpaceState = .inTransition
                        await dismissImmersiveSpace()
                        // Don't set immersiveSpaceState to .closed because there
                        // are multiple paths to ImmersiveView.onDisappear().
                        // Only set .closed in ImmersiveView.onDisappear().

                    case .closed:
                        appModel.immersiveSpaceState = .inTransition
                        switch await openImmersiveSpace(id: appModel.immersiveSpaceID) {
                            case .opened:
                                // Don't set immersiveSpaceState to .open because there
                                // may be multiple paths to ImmersiveView.onAppear().
                                // Only set .open in ImmersiveView.onAppear().
                                break

                            case .userCancelled, .error:
                                // On error, we need to mark the immersive space
                                // as closed because it failed to open.
                                fallthrough
                            @unknown default:
                                // On unknown response, assume space did not open.
                                appModel.immersiveSpaceState = .closed
                        }

                    case .inTransition:
                        // This case should not ever happen because button is disabled for this case.
                        break
                }
            }
        } label: {
            Text(appModel.immersiveSpaceState == .open ? "Hide Immersive Space" : "Show Immersive Space")
        }
        .disabled(appModel.immersiveSpaceState == .inTransition)
        .animation(.none, value: 0)
        .fontWeight(.semibold)
    }
}

################################################################################
FILE: _gisApp.swift
SIZE: 1127 bytes

################################################################################
// _gisApp.swift
import SwiftUI

@main
struct _gisApp: App {
    @State private var appModel = AppModel()

    // Управляемый стиль иммерсии
    @State private var immersionStyle: ImmersionStyle = .mixed

    var body: some Scene {
        // Главное окно
        WindowGroup {
            ContentView()
                .environment(appModel)
        }
        .defaultSize(CGSize(width: 900, height: 800))

        // Окна со стрелкой (три отдельных экземпляра)
        // WindowGroup(id: "ArrowWindow1") {
        //     ArrowWindow(index: 1)
        //         .environment(appModel)
        // }
        // .defaultSize(CGSize(width: 640, height: 320))

        // WindowGroup(id: "ArrowWindow2") {
        //     ArrowWindow(index: 2)
        //         .environment(appModel)
        // }
        // .defaultSize(CGSize(width: 640, height: 320))

        // WindowGroup(id: "ArrowWindow3") {
        //     ArrowWindow(index: 3)
        //         .environment(appModel)
        // }
        // .defaultSize(CGSize(width: 640, height: 320))
    }
}

