
################################################################################
FILE: AppModel.swift
SIZE: 1432 bytes

################################################################################
//
//  AppModel.swift
//  2gis
//
//  Created by –ü–∞–≤–µ–ª on 04.10.2025.
//

import SwiftUI

/// Maintains app-wide state
@MainActor
@Observable
class AppModel {
    let immersiveSpaceID = "ImmersiveSpace"
    enum ImmersiveSpaceState { case closed, inTransition, open }

    // üëá –Ω–æ–≤—ã–π —Ñ–ª–∞–≥ —Ä–µ–∂–∏–º–∞
    enum UIMode { case immersive, menu }
    var uiMode: UIMode = .immersive

    enum SceneSelection: String, CaseIterable, Equatable, Hashable {
        case arrow
        case cube
    }

    var immersiveSpaceState = ImmersiveSpaceState.closed
    var selectedScene: SceneSelection = .arrow

    // ‚úÖ –î–æ–±–∞–≤—å —ç—Ç–æ—Ç —Ñ–ª–∞–≥ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ ContentView –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–∫–æ–Ω
    var hasOpenedArrowWindowOnce: Bool = false

    // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–ª—è —Å—Ç—Ä–µ–ª–∫–∏ (–º) —Å –∂—ë—Å—Ç–∫–∏–º –∫–ª—ç–º–ø–æ–º 1...5
    private(set) var arrowDistance: Float = 1.5
    func setArrowDistance(_ meters: Float) {
        arrowDistance = max(1.0, min(5.0, meters))
    }

    
    // === Route overlay state (–¥–ª—è –æ–∫–Ω–∞ NavigationDemoView –∏ –æ–∫–æ–Ω-–±–∏–ª–±–æ—Ä–¥–æ–≤) ===
    var routeOriginLonLat: (lon: Double, lat: Double)?
    var maneuverNodes: [ManeuverNode] = []
    var routePolyline: RoutePolyline = .init(points: [])
    // —á—Ç–æ–±—ã –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –æ–∫–æ–Ω
    var openedBillboardNodeIDs: Set<UUID> = []
}

################################################################################
FILE: ArrowView.swift
SIZE: 1737 bytes

################################################################################
import SwiftUI

struct ArrowView: View {
    @State private var pulse = false

    var body: some View {
        GeometryReader { geo in
            let size  = min(geo.size.width, geo.size.height)
            let inset = size * 0.1

            ArrowShape()
                .fill(LinearGradient(colors: [Color.cyan, Color.blue],
                                     startPoint: .top, endPoint: .bottom))
                .shadow(color: Color.cyan.opacity(0.5), radius: 16, y: 8)
                .overlay {
                    ArrowShape()
                        .stroke(Color.white.opacity(0.6), lineWidth: 2)
                }
                .scaleEffect(pulse ? 1.05 : 1.0, anchor: .center)
                .animation(.easeInOut(duration: 1.6).repeatForever(autoreverses: true), value: pulse)
                .frame(width: size - inset * 2, height: size - inset * 2)
                .position(x: geo.size.width / 2, y: geo.size.height / 2)
        }
        .onAppear { pulse = true }
    }
}

private struct ArrowShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let w = rect.width
        let h = rect.height
        let headH = h * 0.4

        path.move(to: CGPoint(x: w / 2, y: 0))
        path.addLine(to: CGPoint(x: w,       y: headH))
        path.addLine(to: CGPoint(x: w * 0.68,y: headH))
        path.addLine(to: CGPoint(x: w * 0.68,y: h))
        path.addLine(to: CGPoint(x: w * 0.32,y: h))
        path.addLine(to: CGPoint(x: w * 0.32,y: headH))
        path.addLine(to: CGPoint(x: 0,       y: headH))
        path.closeSubpath()
        return path
    }
}

#Preview {
    ArrowView()
        .frame(width: 640, height: 260)
        .background(Color.clear)
        .padding()
}

################################################################################
FILE: ArrowWindow.swift
SIZE: 551 bytes

################################################################################
import SwiftUI

struct ArrowWindow: View {
    let index: Int

    var body: some View {
        ArrowView()
            .padding(16)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))
            .navigationTitle("–°—Ç—Ä–µ–ª–∫–∞ #\(index)")
            .toolbar {
                ToolbarItem(placement: .status) {
                    Text("–û–∫–Ω–æ —Å–æ —Å—Ç—Ä–µ–ª–∫–æ–π #\(index)")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
            }
    }
}

################################################################################
FILE: CatalogAPIClient.swift
SIZE: 6177 bytes

################################################################################
import Foundation

struct CatalogAPIClient {
    enum APIError: LocalizedError { case invalidURL, http(Int), decoding(Error) }

    struct Configuration: Sendable {
        let baseV3: URL
        static let production = Configuration(baseV3: URL(string: "https://catalog.api.2gis.com/3.0")!)
    }

    private let apiKey: String
    private let session: URLSession
    private let config: Configuration
    private let decoder: JSONDecoder

    init(apiKey: String, session: URLSession = .shared, config: Configuration = .production) {
        self.apiKey = apiKey
        self.session = session
        self.config = config
        let d = JSONDecoder()
        d.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder = d
    }

    // MARK: Endpoints

    func geocodeBuilding(lon: Double, lat: Double, radius: Int? = 50) async throws -> GeocodeResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items/geocode"), resolvingAgainstBaseURL: false)!
        var qi: [URLQueryItem] = [
            .init(name: "lon", value: String(lon)),
            .init(name: "lat", value: String(lat)),
            .init(name: "type", value: "building"),
            .init(name: "key", value: apiKey)
        ]
        if let radius { qi.append(.init(name: "radius", value: String(radius))) }
        comp.queryItems = qi
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: GeocodeResponse.self)
    }

    func buildingDetails(id: String, fields: String?) async throws -> BuildingDetailsResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items/byid"), resolvingAgainstBaseURL: false)!
        var items = [URLQueryItem(name: "id", value: id), URLQueryItem(name: "key", value: apiKey)]
        if let fields, !fields.isEmpty { items.append(.init(name: "fields", value: fields)) }
        comp.queryItems = items
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: BuildingDetailsResponse.self)
    }

    func listIndoorOrganizations(buildingId: String, page: Int = 1, pageSize: Int = 12) async throws -> PlacesSearchResponse {
        var comp = URLComponents(url: config.baseV3.appendingPathComponent("items"), resolvingAgainstBaseURL: false)!
        comp.queryItems = [
            .init(name: "key", value: apiKey),
            .init(name: "building_id", value: buildingId),
            .init(name: "search_type", value: "indoor"),
            .init(name: "page", value: String(page)),
            .init(name: "page_size", value: String(pageSize))
        ]
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: PlacesSearchResponse.self)
    }

    func listServicing(buildingId: String, group: String = "default", fields: String? = nil, page: Int = 1, pageSize: Int = 12) async throws -> PlacesSearchResponse {
        var comp = URLComponents(url: URL(string: "https://catalog.api.2gis.com")!.appendingPathComponent("3.0/items/byservicing"), resolvingAgainstBaseURL: false)!
        var items = [
            URLQueryItem(name: "key", value: apiKey),
            URLQueryItem(name: "building_id", value: buildingId),
            URLQueryItem(name: "servicing_group", value: group),
            URLQueryItem(name: "page", value: String(page)),
            URLQueryItem(name: "page_size", value: String(pageSize))
        ]
        if let fields, !fields.isEmpty { items.append(.init(name: "fields", value: fields)) }
        comp.queryItems = items
        let req = URLRequest(url: comp.url!)
        return try await send(req, decode: PlacesSearchResponse.self)
    }

    // MARK: Sending
    private func send<T: Decodable>(_ req: URLRequest, decode: T.Type) async throws -> T {
        let (data, resp) = try await session.data(for: req)
        guard let http = resp as? HTTPURLResponse else { throw APIError.invalidURL }
        guard 200..<300 ~= http.statusCode else { throw APIError.http(http.statusCode) }
        do { return try decoder.decode(T.self, from: data) } catch { throw APIError.decoding(error) }
    }
}

// MARK: Models

struct GeocodeResponse: Decodable {
    struct Result: Decodable { let items: [GeocodeItem]?; let total: Int? }
    let meta: Meta?
    let result: Result?
}

struct GeocodeItem: Decodable, Identifiable { let id: String; let name: String; let fullName: String?; let type: String }

struct BuildingDetailsResponse: Decodable {
    struct Result: Decodable { let items: [BuildingDetails]?; let total: Int? }
    let meta: Meta?
    let result: Result?
}

struct BuildingDetails: Decodable, Identifiable {
    struct Point: Decodable { let lon: Double?; let lat: Double? }
    struct StructureInfo: Decodable {
        let material: String?
        let apartmentsCount: Int?
        let porchCount: Int?
        let floorType: String?
        let gasType: String?
        let yearOfConstruction: Int?
        let elevatorsCount: Int?
        let isInEmergencyState: Bool?
        let projectType: String?
        let chsName: String?
        let chsCategory: String?
    }
    let id: String
    let name: String
    let addressName: String?
    let type: String
    let floors: Int?
    let point: Point?
    let structureInfo: StructureInfo?
}

struct Meta: Decodable { let apiVersion: String?; let code: Int?; let issueDate: String? }

struct PlacesSearchResponse: Decodable {
    struct Result: Decodable { let items: [PlaceItem]? }
    let meta: Meta?
    let result: Result?
}

struct PlaceItem: Decodable, Identifiable {
    struct Point: Decodable { let lon: Double?; let lat: Double? }
    struct ContactGroup: Decodable { let name: String?; let contacts: [Contact]?; struct Contact: Decodable { let type: String?; let value: String? } }
    struct WorkingHours: Decodable { let text: String? }
    let id: String
    let name: String?
    let addressName: String?
    let point: Point?
    let rubrics: [Rubric]?
    let contactGroups: [ContactGroup]?
    let workingHours: WorkingHours?
    let links: [String: String]? // keep flexible
    let rating: Double?
    let reviewsCount: Int?
    struct Rubric: Decodable { let name: String? }
}


################################################################################
FILE: CatalogFlowViewModel.swift
SIZE: 4015 bytes

################################################################################
import Foundation
import Observation

@MainActor
@Observable
class CatalogFlowViewModel {
    struct FlowResult: Sendable {
        var building: BuildingDetails?
        var organizations: [PlaceItem]
        var diagnostics: [String]
    }

    private let client: CatalogAPIClient

    var isRunning: Bool = false
    var lastResult: FlowResult?
    var lastError: String?

    init(apiKey: String = "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe") {
        self.client = CatalogAPIClient(apiKey: apiKey)
    }

    func run(lon: Double, lat: Double) async {
        guard !isRunning else { return }
        isRunning = true
        lastError = nil
        var diagnostics: [String] = []

        var buildingId: String?
        var buildingDetails: BuildingDetails?
        var organizations: [PlaceItem] = []

        // 1) Nearest building via geocoder with increasing radius
        do {
            let radii = [10, 50, 150, 300]
            var found: GeocodeItem?
            for r in radii {
                let geo = try await client.geocodeBuilding(lon: lon, lat: lat, radius: r)
                if let item = geo.result?.items?.first {
                    found = item
                    diagnostics.append("geocode: hit radius=\(r)")
                    break
                } else {
                    diagnostics.append("geocode: empty radius=\(r)")
                }
            }
            buildingId = found?.id
        } catch {
            diagnostics.append("geocode error: \(error.localizedDescription)")
        }

        // 2) Building details by id (best-effort)
        if let id = buildingId {
            let fields = "items.address,items.floors,items.structure_info.material,items.structure_info.apartments_count,items.structure_info.porch_count,items.structure_info.floor_type,items.structure_info.year_of_construction,items.structure_info.elevators_count,items.structure_info.gas_type,items.structure_info.project_type,items.structure_info.chs_name,items.structure_info.chs_category"
            do {
                let resp = try await client.buildingDetails(id: id, fields: fields)
                buildingDetails = resp.result?.items?.first
                if buildingDetails == nil { diagnostics.append("details: no items") }
            } catch {
                diagnostics.append("details error: \(error.localizedDescription)")
            }
        } else {
            diagnostics.append("no building id ‚Äî skipping details & orgs")
        }

        // 3) Organizations inside building (fallback to servicing)
        if let id = buildingId {
            do {
                let resp = try await client.listIndoorOrganizations(buildingId: id, page: 1, pageSize: 12)
                organizations = resp.result?.items ?? []
                if organizations.isEmpty {
                    diagnostics.append("indoor: empty; try byservicing")
                    do {
                        let svc = try await client.listServicing(buildingId: id, group: "default", fields: "items.contact_groups,items.working_hours,items.links")
                        organizations = svc.result?.items ?? []
                    } catch {
                        diagnostics.append("byservicing error: \(error.localizedDescription)")
                    }
                }
            } catch {
                diagnostics.append("indoor error: \(error.localizedDescription)")
                // Try servicing even if indoor failed
                do {
                    let svc = try await client.listServicing(buildingId: id, group: "default", fields: "items.contact_groups,items.working_hours,items.links")
                    organizations = svc.result?.items ?? []
                } catch {
                    diagnostics.append("byservicing error: \(error.localizedDescription)")
                }
            }
        }

        self.lastResult = FlowResult(building: buildingDetails, organizations: organizations, diagnostics: diagnostics)
        isRunning = false
    }
}


################################################################################
FILE: ContentView.swift
SIZE: 18732 bytes

################################################################################
//
//  ContentView.swift
//  2gis
//
//  Created by –ü–∞–≤–µ–ª on 04.10.2025.
//

import SwiftUI
import RealityKit
import Observation

struct ContentView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.openWindow) private var openWindow

    @State private var navigationViewModel = NavigationViewModel()
    @State private var catalogViewModel = CatalogFlowViewModel()

    @State private var destPoint: RoutePoint = RoutePoint(lon: 0, lat: 0, type: RoutePoint.PointType.stop)
    @State private var destinationPlaceText: String = ""

    @State private var lonText: String = "37.625325"
    @State private var latText: String = "55.695281"

    // –¢–µ–∫—É—â–∞—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏—è (–¥–ª—è echo-origin –∏ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞)
    @State private var locationService = LocationService()

    // –ß—Ç–æ–±—ã –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –º–∞—Ä—à—Ä—É—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ
    @State private var lastProcessedRouteToken: String?

    // –°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω –¥–ª—è .task(id:) ‚Äî –±–µ—Ä—ë–º route.id; –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç, –¥–µ–ª–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∫–ª—é—á
    private var routeToken: String {
        if let r = navigationViewModel.lastRouteResponse?.result?.first {
            return (r.id ?? "no-id") + "|\(r.maneuvers?.count ?? -1)"
        }
        return "no-route"
    }

    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                // –¢–µ–∫—É—â–∏–µ GPS-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                gpsBlock

                Divider()

                // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Navigation API
                NavigationDemoView(
                    viewModel: navigationViewModel,
                    addrText: $destinationPlaceText,
                    locationService: $locationService,
                    destPoint: $destPoint
                )

                // –≠—Å–∫–∏–∑ –≤—Å–µ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞ (–ø–æ –º–∞–Ω—ë–≤—Ä–∞–º –∏ –ø–æ–ª–Ω–æ–π –ø–æ–ª–∏–ª–∏–Ω–∏–∏)
                RouteOverlayPanel(
                    origin: appModel.routeOriginLonLat,
                    polyline: appModel.routePolyline,
                    nodes: appModel.maneuverNodes
                )

                Divider()

                // –ö–∞—Ç–∞–ª–æ–≥ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
                CatalogFlowSection(
                    viewModel: catalogViewModel,
                    lonText: $lonText,
                    latText: $latText
                )
            }
            .padding(24)
        }
        .onAppear {
            locationService.distanceThresholdMeters = 1.0
            locationService.start()
        }
        .onChange(of: locationService.currentLocation) { _, newLoc in
            guard let loc = newLoc else { return }
            lonText = String(format: "%.6f", loc.coordinate.longitude)
            latText = String(format: "%.6f", loc.coordinate.latitude)

            if locationService.checkAndSnapIfNeeded() {
                Task {
                    await catalogViewModel.run(
                        lon: loc.coordinate.longitude,
                        lat: loc.coordinate.latitude
                    )
                }
            }
        }
        // ‚úÖ –ë–ï–ó Equatable: –ø–æ–±–æ—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ —Å–º–µ–Ω–µ –º–∞—Ä—à—Ä—É—Ç–∞ ‚Äî —á–µ—Ä–µ–∑ .task(id:)
        // SwiftUI –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç —ç—Ç–æ—Ç –±–ª–æ–∫, –∫–æ–≥–¥–∞ –ø–æ–º–µ–Ω—è–µ—Ç—Å—è routeToken (–æ–±—ã—á–Ω–æ = route.id).
        .task(id: routeToken) {
            guard routeToken != "no-route",
                  routeToken != lastProcessedRouteToken,
                  let resp = navigationViewModel.lastRouteResponse else { return }

            // 1) Origin ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ–º –Ω–∞ –º–æ–º–µ–Ω—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞
            if let loc = locationService.currentLocation {
                appModel.routeOriginLonLat = (
                    lon: loc.coordinate.longitude,
                    lat: loc.coordinate.latitude
                )
            } else {
                // –§–æ–ª–ª–±—ç–∫: –µ—Å–ª–∏ –Ω–µ—Ç GPS, –≤–æ–∑—å–º—ë–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –∏–∑ –ø–æ–ª–∏–ª–∏–Ω–∏–∏ (–Ω–∏–∂–µ –µ—ë –ø–æ—Å—Ç—Ä–æ–∏–º)
                appModel.routeOriginLonLat = nil
            }

            // 2) –£–∑–ª—ã –º–∞–Ω—ë–≤—Ä–æ–≤ + —Ü–µ–ª—å–Ω–∞—è –ø–æ–ª–∏–ª–∏–Ω–∏—è (–ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∏–∂–µ)
            let nodes = extractManeuverNodes(from: resp)
            var full  = extractFullPolyline(from: resp)

            // –ï—Å–ª–∏ origin –µ—â—ë –ø—É—Å—Ç ‚Äî –≤—ã–±–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞
            if appModel.routeOriginLonLat == nil {
                if let first = full.points.first {
                    appModel.routeOriginLonLat = (lon: first.lon, lat: first.lat)
                } else if let n = nodes.first {
                    appModel.routeOriginLonLat = (lon: n.lon, lat: n.lat)
                }
            }

            appModel.maneuverNodes = nodes
            appModel.routePolyline = full

            // 3) –ê–≤—Ç–æ–ø–æ–¥—ä—ë–º –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö –æ–∫–æ–Ω-–±–∏–ª–±–æ—Ä–¥–æ–≤ –ø–æ –≤—Å–µ–º —É–∑–ª–∞–º (–æ–≥—Ä–∞–Ω–∏—á–∏–º —á–∏—Å–ª–æ)
            let maxWindows = 8
            for node in nodes.prefix(maxWindows) where !appModel.openedBillboardNodeIDs.contains(node.id) {
                openWindow(id: "SignpostWindow", value: node)
                appModel.openedBillboardNodeIDs.insert(node.id)
            }

            lastProcessedRouteToken = routeToken
        }
    }

    // MARK: - GPS Block

    private var gpsBlock: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("GPS")
                .font(.title3).bold()
            switch locationService.status {
            case .authorized:
                if let loc = locationService.currentLocation {
                    Text(String(format: "Lat: %.6f, Lon: %.6f (¬±%.0f –º)",
                                loc.coordinate.latitude,
                                loc.coordinate.longitude,
                                loc.horizontalAccuracy))
                        .font(.callout)
                        .foregroundStyle(.secondary)
                } else {
                    Text("–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö‚Ä¶").foregroundStyle(.secondary)
                }
            case .requesting:
                Text("–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ‚Ä¶").foregroundStyle(.secondary)
            case .denied:
                Text("–î–æ—Å—Ç—É–ø –∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –∑–∞–ø—Ä–µ—â—ë–Ω. –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.")
                    .foregroundStyle(.red)
            case .restricted:
                Text("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã).")
                    .foregroundStyle(.red)
            case .idle:
                Text("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞‚Ä¶").foregroundStyle(.secondary)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 12))
    }
}

// MARK: - NavigationDemoView (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)

private struct NavigationDemoView: View {
    @Environment(AppModel.self) private var appModel
    @Bindable var viewModel: NavigationViewModel
    @Binding var addrText: String
    @Binding var locationService: LocationService
    @Binding var destPoint: RoutePoint

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("2GIS Navigation APIs").font(.title2).bold()

            TextField("addr", text: $addrText)
                .textFieldStyle(.roundedBorder)
                .keyboardType(.numbersAndPunctuation)

            HStack {
                Button(action: savePointFromAddr) {
                    Label("–ù–∞–π—Ç–∏ –∞–¥—Ä–µ—Å—Å—Å", systemImage: "house")
                }
                Button(action: loadRoute) {
                    Label("–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç", systemImage: "car")
                }
                .disabled(viewModel.isLoading)
            }
            .buttonStyle(.borderedProminent)

            if viewModel.isLoading { ProgressView() }

            if let error = viewModel.errorMessage {
                Text(error).foregroundStyle(.red)
            }

            if let route = viewModel.lastRouteResponse?.result?.first {
                VStack(alignment: .leading, spacing: 8) {
                    Text("–ú–∞—Ä—à—Ä—É—Ç: \(route.id ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")").font(.headline)
                    if let algorithm = route.algorithm {
                        Text("–ê–ª–≥–æ—Ä–∏—Ç–º: \(algorithm)").font(.subheadline)
                    }
                    if let maneuvers = route.maneuvers {
                        Text("–ú–∞–Ω—ë–≤—Ä—ã").font(.subheadline).bold()
                        ForEach(Array(maneuvers.prefix(3).enumerated()), id: \.offset) { index, maneuver in
                            Text("\(index + 1). \(maneuver.comment ?? "‚Äî")").font(.footnote)
                        }
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
                .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
            } else {
                Text("–ü–æ—Å—Ç—Ä–æ–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –æ–≤–µ—Ä–ª–µ–π.")
                    .foregroundStyle(.secondary)
            }
        }
    }

    private func savePointFromAddr() {
        Task {
            do {
                let client = DGisPlacesClient(
                    config: DGisPlacesClient.Config(apiKey: "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe")
                )
                let best = try await client.bestMatch(self.addrText)
                guard let p = best.point, let lon = p.lon, let lat = p.lat else { return }
                await MainActor.run {
                    self.addrText = best.addressName ?? best.name
                    self.destPoint = RoutePoint(lon: lon, lat: lat, type: .stop)
                }
            } catch {
                print("Search failed:", error)
            }
        }
    }

    private func loadRoute() {
        Task { await viewModel.loadSampleRoute(locationService: locationService, destinationPoint: destPoint) }
    }
}

// MARK: - Catalog Flow Section (–∫–∞–∫ –±—ã–ª–æ)

private struct CatalogFlowSection: View {
    @Bindable var viewModel: CatalogFlowViewModel
    @Binding var lonText: String
    @Binding var latText: String

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("–ó–¥–∞–Ω–∏–µ –∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ")
                .font(.title3).bold()

            HStack(spacing: 12) {
                TextField("lon", text: $lonText)
                    .textFieldStyle(.roundedBorder)
                    .keyboardType(.numbersAndPunctuation)
                TextField("lat", text: $latText)
                    .textFieldStyle(.roundedBorder)
                    .keyboardType(.numbersAndPunctuation)
                Button {
                    Task {
                        if let lon = Double(lonText), let lat = Double(latText) {
                            await viewModel.run(lon: lon, lat: lat)
                        }
                    }
                } label: {
                    Label("–ù–∞–π—Ç–∏", systemImage: "building.2")
                }
                .disabled(viewModel.isRunning)
            }

            if viewModel.isRunning { ProgressView() }

            if let result = viewModel.lastResult {
                if let b = result.building {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(b.name).font(.headline)
                        if let addr = b.addressName { Text(addr).font(.subheadline) }
                        HStack(spacing: 8) {
                            if let floors = b.floors { Text("–≠—Ç–∞–∂–µ–π: \(floors)") }
                            if let material = b.structureInfo?.material { Text("–ú–∞—Ç–µ—Ä–∏–∞–ª: \(material)") }
                            if let year = b.structureInfo?.yearOfConstruction { Text("–ì–æ–¥: \(year)") }
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding()
                    .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 12))
                } else {
                    Text("–ó–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Ä—è–¥–æ–º —Å —Ç–æ—á–∫–æ–π").foregroundStyle(.secondary)
                }

                if !result.organizations.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –≤–Ω—É—Ç—Ä–∏").font(.headline)
                        ForEach(result.organizations, id: \.id) { org in
                            VStack(alignment: .leading, spacing: 2) {
                                Text(org.name ?? "‚Äî").font(.subheadline).bold()
                                if let addr = org.addressName { Text(addr).font(.footnote).foregroundStyle(.secondary) }
                                if let rub = org.rubrics?.compactMap({ $0.name }).first { Text(rub).font(.footnote) }
                            }
                            .padding(8)
                            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 10))
                        }
                    }
                } else {
                    Text("–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã").foregroundStyle(.secondary)
                }

                if !result.diagnostics.isEmpty {
                    Text(result.diagnostics.joined(separator: " ¬∑ "))
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
            }
        }
    }
}

// MARK: - 2D Sketch Panel (Canvas) ‚Äî –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç + —É–∑–ª—ã –º–∞–Ω—ë–≤—Ä–æ–≤

struct RouteOverlayPanel: View {
    let origin: (lon: Double, lat: Double)?
    let polyline: RoutePolyline
    let nodes: [ManeuverNode]

    private let panelHeight: CGFloat = 240

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("–ú–∞—Ä—à—Ä—É—Ç (—ç—Å–∫–∏–∑)").font(.headline)
            Canvas { ctx, size in
                guard let origin, !polyline.points.isEmpty else {
                    ctx.draw(Text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏"),
                             at: CGPoint(x: size.width/2, y: size.height/2))
                    return
                }
                // 1) –ì–µ–æ ‚Üí ¬´–º–µ—Ç—Ä—ã¬ª (–ª–æ–∫–∞–ª—å–Ω–∞—è ENU –æ—Ç origin)
                let meters: [SIMD2<Double>] = polyline.points.map {
                    Geo.geoToMeters(lon: $0.lon, lat: $0.lat,
                                    originLon: origin.lon, originLat: origin.lat)
                }

                // 2) –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤ –≤–∏–¥–∂–µ—Ç —Å –æ—Ç—Å—Ç—É–ø–∞–º–∏
                let inset = 18.0
                let xs = meters.map { $0.x }, zs = meters.map { $0.y }
                guard let minX = xs.min(), let maxX = xs.max(),
                      let minZ = zs.min(), let maxZ = zs.max() else { return }
                let w = max(maxX - minX, 1.0), h = max(maxZ - minZ, 1.0)
                let scale = min(Double(size.width - inset*2)/w,
                                Double(size.height - inset*2)/h)

                func mapPoint(_ m: SIMD2<Double>) -> CGPoint {
                    let x = (m.x - minX) * scale + inset
                    let y = (m.y - minZ) * scale + inset
                    // –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ (—ç–∫—Ä–∞–Ω–Ω–∞—è Y –≤–Ω–∏–∑)
                    return CGPoint(x: x, y: Double(size.height) - y)
                }

                // 3) –õ–∏–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞
                var path = Path()
                path.move(to: mapPoint(meters[0]))
                for i in 1..<meters.count { path.addLine(to: mapPoint(meters[i])) }
                ctx.stroke(path, with: .color(.white.opacity(0.85)), lineWidth: 4)

                // 4) –£–∑–ª—ã-–º–∞–Ω—ë–≤—Ä—ã
                for (i, n) in nodes.enumerated() {
                    let p2 = Geo.geoToMeters(lon: n.lon, lat: n.lat,
                                             originLon: origin.lon, originLat: origin.lat)
                    let p = mapPoint(p2)
                    let r: CGFloat = (i == 0 || i == nodes.count-1) ? 6 : 4
                    let rect = CGRect(x: p.x - r, y: p.y - r, width: r*2, height: r*2)
                    ctx.fill(Path(ellipseIn: rect),
                             with: .color(i == 0 ? .green : (i == nodes.count-1 ? .red : .cyan)))
                }
            }
            .frame(height: panelHeight)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 12))
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

// MARK: - –õ–æ–∫–∞–ª—å–Ω—ã–µ —Ö–µ–ª–ø–µ—Ä—ã –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ RouteResponse (–±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –æ—Ç ViewModel)

private func extractManeuverNodes(from response: RouteResponse) -> [ManeuverNode] {
    guard let route = response.result?.first, let mans = route.maneuvers else { return [] }
    return mans.compactMap { m in
        guard let sel = m.outcomingPath?.geometry?.first?.selection else { return nil }
        guard let first = WKT.parseLineString(sel).first else { return nil }
        let t: String
        switch (m.icon ?? "") {
        case "turn_right": t = "‚Ü±"
        case "turn_left":  t = "‚Ü∞"
        case "finish":     t = "‚óè"
        case "start":      t = "‚óé"
        default:           t = "‚¨ÜÔ∏é"
        }
        return ManeuverNode(lon: first.lon, lat: first.lat, title: t, detail: m.outcomingPathComment ?? m.comment)
    }
}

private func extractFullPolyline(from response: RouteResponse) -> RoutePolyline {
    guard let route = response.result?.first, let mans = route.maneuvers else {
        return .init(points: [])
    }
    var all: [GeoPoint] = []
    for m in mans {
        if let sel = m.outcomingPath?.geometry?.first?.selection {
            let pts = WKT.parseLineString(sel) // [(lon, lat)]
            guard !pts.isEmpty else { continue }
            if let last = all.last, let first = pts.first,
               last.lon == first.lon, last.lat == first.lat {
                all.append(contentsOf: pts.dropFirst().map { GeoPoint(lon: $0.lon, lat: $0.lat) })
            } else {
                all.append(contentsOf: pts.map { GeoPoint(lon: $0.lon, lat: $0.lat) })
            }
        }
    }
    return .init(points: all)
}

################################################################################
FILE: GeoOverlay.swift
SIZE: 52 bytes

################################################################################
// GeoOverlay.swift
import Foundation
import simd



################################################################################
FILE: ImmersiveView.swift
SIZE: 11315 bytes

################################################################################
//
//  ImmersiveView.swift
//  2gis
//
//  Created by –ü–∞–≤–µ–ª on 04.10.2025.
//

import SwiftUI
import RealityKit
import UIKit // –¥–ª—è UIColor

struct ImmersiveView: View {
    @Environment(AppModel.self) var appModel

    var body: some View {
        RealityView { content in
            // ---------- HEAD (—Å—Ç—Ä–µ–ª–∫–∞) ----------
            let headAnchor = AnchorEntity(.head)
            headAnchor.name = "HeadAnchor"

            // –ü–ª–æ—Å–∫–∞—è –ø–ª–∞—à–∫–∞-—Å—Ç—Ä–µ–ª–∫–∞, —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—Ç—Ä–∏ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å —à–∞–≥–æ–º 1 –º)
            let arrowSize: SIMD2<Float> = [0.40, 0.18]
            let mesh = MeshResource.generatePlane(width: arrowSize.x, height: arrowSize.y, cornerRadius: 0.03)

            func makeArrow(name: String, color: UIColor) -> ModelEntity {
                var mat = UnlitMaterial()
                mat.color = .init(tint: color)
                let e = ModelEntity(mesh: mesh, materials: [mat])
                e.name = name
                e.components.set(BillboardComponent()) // –≤—Å–µ–≥–¥–∞ –∫ –∫–∞–º–µ—Ä–µ :contentReference[oaicite:1]{index=1}
                return e
            }

            let arrow1 = makeArrow(name: "ArrowBillboard1", color: UIColor(red: 0.0, green: 0.7, blue: 1.0, alpha: 1.0))
            let arrow2 = makeArrow(name: "ArrowBillboard2", color: UIColor(red: 0.1, green: 0.9, blue: 0.6, alpha: 1.0))
            let arrow3 = makeArrow(name: "ArrowBillboard3", color: UIColor(red: 1.0, green: 0.5, blue: 0.2, alpha: 1.0))

            let d0 = max(1.0 as Float, min(5.0 as Float, appModel.arrowDistance))
            arrow1.position = [0.0, 0.0, -d0]
            arrow2.position = [0.0, 0.0, -(d0 + 1.0)]
            arrow3.position = [0.0, 0.0, -(d0 + 2.0)]

            headAnchor.addChild(arrow1)
            headAnchor.addChild(arrow2)
            headAnchor.addChild(arrow3)
            headAnchor.isEnabled = (appModel.selectedScene == .arrow)
            content.add(headAnchor)

            // ---------- WORLD (–∫—É–±) ----------
            let worldAnchor = AnchorEntity(world: SIMD3<Float>(0, 1.4, -1.5))
            worldAnchor.name = "WorldAnchorCube"

            let cube = ModelEntity(mesh: .generateBox(size: 0.45, cornerRadius: 0.06))
            cube.model?.materials = [
                SimpleMaterial(color: UIColor(red: 0.15, green: 0.55, blue: 0.95, alpha: 1.0),
                               roughness: 0.25, isMetallic: true)
            ]
            cube.transform.rotation = simd_quatf(angle: .pi / 6, axis: SIMD3<Float>(1, 1, 0))
            worldAnchor.addChild(cube)

            let key = DirectionalLight()
            key.light.color = UIColor(red: 1.0, green: 0.95, blue: 0.9, alpha: 1.0)
            key.light.intensity = 2_000
            key.shadow = DirectionalLightComponent.Shadow(maximumDistance: 10, depthBias: 0.02)
            key.look(at: .zero, from: [1.5, 1.5, 1.0], relativeTo: worldAnchor)
            worldAnchor.addChild(key)

            let fill = DirectionalLight()
            fill.light.color = UIColor(white: 0.8, alpha: 1.0)
            fill.light.intensity = 600
            fill.look(at: .zero, from: [-1.0, 0.8, -0.5], relativeTo: worldAnchor)
            worldAnchor.addChild(fill)

            worldAnchor.isEnabled = (appModel.selectedScene == .cube)
            content.add(worldAnchor)

            // ---------- ROUTE OVERLAY (—É–∑–ª—ã –º–∞–Ω—ë–≤—Ä–æ–≤) ----------
            let routeAnchor = AnchorEntity(.head) // –¥–µ—Ä–∂–∏–º –≤ –ø–æ–ª–µ –∑—Ä–µ–Ω–∏—è –∏ –Ω–∞ –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
            routeAnchor.name = "RouteAnchor"
            content.add(routeAnchor)

        } update: { content in
            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—é —Å—Ç—Ä–µ–ª–æ–∫ (–≤—Å–µ–≥–¥–∞ 1‚Ä¶5 –º), —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º 1 –º
            let d = max(1.0 as Float, min(5.0 as Float, appModel.arrowDistance))
            if let a1 = content.entities.first(where: { $0.name == "ArrowBillboard1" }) as? ModelEntity {
                a1.position = [0, 0, -d]
            }
            if let a2 = content.entities.first(where: { $0.name == "ArrowBillboard2" }) as? ModelEntity {
                a2.position = [0, 0, -(d + 1.0)]
            }
            if let a3 = content.entities.first(where: { $0.name == "ArrowBillboard3" }) as? ModelEntity {
                a3.position = [0, 0, -(d + 2.0)]
            }
            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å—Ü–µ–Ω—ã –±–µ–∑ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è
            if let headAnchor = content.entities.first(where: { $0.name == "HeadAnchor" }) {
                headAnchor.isEnabled = (appModel.selectedScene == .arrow)
            }
            if let worldAnchor = content.entities.first(where: { $0.name == "WorldAnchorCube" }) {
                worldAnchor.isEnabled = (appModel.selectedScene == .cube)
            }

            // [ROUTE OVERLAY] ‚Äî –≥–≤–∞—Ä–¥—ã
            guard let origin = appModel.routeOriginLonLat, !appModel.maneuverNodes.isEmpty else {
                if let a = content.entities.first(where: { $0.name == "RouteAnchor" }) {
                    a.children.forEach { $0.removeFromParent() }
                }
                return
            }

            guard let routeAnchor = content.entities.first(where: { $0.name == "RouteAnchor" }) as? AnchorEntity else {
                return
            }

            // 1) –í—ã–±–∏—Ä–∞–µ–º –±–ª–∏–∂–∞–π—à–∏–π "—Å–ª–µ–¥—É—é—â–∏–π" –º–∞–Ω—ë–≤—Ä ‚Äî —É–ø—Ä–æ—â—ë–Ω–Ω–æ: –ø–µ—Ä–≤—ã–π —É–∑–µ–ª
            let next = appModel.maneuverNodes.first!

            // 2) –ü–æ–∑–∏—Ü–∏—è —Ç–∞–±–ª–∏—á–∫–∏
            let nextPos = Geo.geoToMeters(
                lon: next.lon, lat: next.lat,
                originLon: origin.lon, originLat: origin.lat
            )
            let signY: Float = 1.4
            let signName = "RouteSignpost"

            // 2.1) –ù–∞–π—Ç–∏/—Å–æ–∑–¥–∞—Ç—å —Ç–∞–±–ª–∏—á–∫—É
            let sign: Entity
            if let existing = routeAnchor.children.first(where: { $0.name == signName }) {
                sign = existing
            } else {
                let e = makeSignpost(title: next.title, detail: next.detail)
                e.name = signName
                routeAnchor.addChild(e)
                sign = e
            }

            // 2.2) –û–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–¥–∏–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π mesh
            sign.children.forEach { child in
                if child is ModelEntity { child.removeFromParent() }
            }
            let wanted = [next.title, next.detail].compactMap { $0 }.joined(separator: "\n")
            if let textEntity = makeTextEntity(wanted) {
                textEntity.position = [0, 0, 0.001]
                sign.addChild(textEntity)
            }

            // 2.3) –ü–æ–∑–∏—Ü–∏—è/–Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–∞–±–ª–∏—á–∫–∏
            //sign.position = [nextPos.x, signY, nextPos.z]
            if sign.components[BillboardComponent.self] == nil {
                sign.components.set(BillboardComponent()) // –≤—Å–µ–≥–¥–∞ –∫ –∫–∞–º–µ—Ä–µ :contentReference[oaicite:2]{index=2}
            }

            // 3) –û—Ç—Ä–∏—Å–æ–≤–∞—Ç—å 2‚Äì3 –±–ª–∏–∂–∞–π—à–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–∞ –º–µ–∂–¥—É —É–∑–ª–∞–º–∏ (—Ç–æ–Ω–∫–∏–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏)
            let maxSegments = 3
            let segRootName = "RouteSegmentsRoot"
            let segRoot: Entity = {
                if let ex = routeAnchor.children.first(where: { $0.name == segRootName }) { return ex }
                let r = Entity()
                r.name = segRootName
                routeAnchor.addChild(r)
                return r
            }()

            // –ø–æ–¥—á–∏—Å—Ç–∏–º —Å—Ç–∞—Ä—ã–µ –¥–µ—Ç–∫–∏ (–ø–µ—Ä–µ—Ä–∏—Å—É–µ–º –±—ã—Å—Ç—Ä–æ)
            segRoot.children.forEach { $0.removeFromParent() }

            let nodes = appModel.maneuverNodes
            if nodes.count >= 2 {
                for i in 0..<(min(nodes.count - 1, maxSegments)) {
                    let a = nodes[i], b = nodes[i + 1]
                    let pa = Geo.geoToMeters(lon: a.lon, lat: a.lat, originLon: origin.lon, originLat: origin.lat)
                    let pb = Geo.geoToMeters(lon: b.lon, lat: b.lat, originLon: origin.lon, originLat: origin.lat)
                    //if let seg = makeThinSegment(from: pa, to: pb, width: 0.25) {
                    //    segRoot.addChild(seg)
                    //}
                }
            }
        }
        .onAppear { appModel.immersiveSpaceState = .open }
        .onDisappear { appModel.immersiveSpaceState = .closed }
    }
}

// MARK: - Route overlay helpers

/// –ü–ª–æ—Å–∫–∞—è —Ç–∞–±–ª–∏—á–∫–∞-–±–∏–ª–±–æ—Ä–¥ (–±–µ–∑ —Ç–µ–∫—Å—Ç–∞; —Ç–µ–∫—Å—Ç –¥–æ–±–∞–≤–ª—è–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ)
private func makeSignpost(title: String, detail: String?) -> Entity {
    let panelMesh = MeshResource.generatePlane(width: Float(0.35), height: Float(0.16), cornerRadius: Float(0.02))
    var panelMat = UnlitMaterial()
    panelMat.color = .init(tint: UIColor(white: 1.0, alpha: 0.85)) // –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –±–µ–ª–∞—è –ø–∞–Ω–µ–ª—å :contentReference[oaicite:3]{index=3}
    let panel = ModelEntity(mesh: panelMesh, materials: [panelMat])
    panel.components.set(BillboardComponent()) // —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –∫–∞–º–µ—Ä—É :contentReference[oaicite:4]{index=4}
    // –ø–µ—Ä–≤–∏—á–Ω–æ–µ –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏–µ (–µ—Å–ª–∏ –µ—Å—Ç—å)
    let textStr = [title, detail].compactMap { $0 }.joined(separator: "\n")
    if let textEntity = makeTextEntity(textStr) {
        textEntity.position = [0, 0, 0.001]
        panel.addChild(textEntity)
    }
    return panel
}

/// –¢–µ–∫—Å—Ç –∫–∞–∫ MeshResource ‚Üí ModelEntity
private func makeTextEntity(_ string: String) -> ModelEntity? {
    // –®—Ä–∏—Ñ—Ç RealityKit –¥–ª—è text mesh
    let font = MeshResource.Font.systemFont(ofSize: 0.06, weight: .semibold) // :contentReference[oaicite:5]{index=5}
    let textMesh = MeshResource.generateText(
        string,
        extrusionDepth: 0.001,     // –æ—á–µ–Ω—å —Ç–æ–Ω–∫–∏–π –æ–±—ä—ë–º
        font: font                 // —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø–æ–ª—É–∂–∏—Ä–Ω—ã–π
        // –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã
    ) // :contentReference[oaicite:6]{index=6}
    var textMat = UnlitMaterial()
    textMat.color = .init(tint: UIColor.black)
    return ModelEntity(mesh: textMesh, materials: [textMat])
}

/// –£–∑–∫–∏–π —Å–µ–≥–º–µ–Ω—Ç –º–µ–∂–¥—É –¥–≤—É–º—è —É–∑–ª–∞–º–∏ (–≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ XZ)
private func makeThinSegment(from a: SIMD3<Float>, to b: SIMD3<Float>, width: Float) -> Entity? {
    let dx = b.x - a.x
    let dz = b.z - a.z
    let len = sqrt(dx * dx + dz * dz)
    guard len > 0.05 else { return nil }
    let mid = SIMD3<Float>((a.x + b.x) / 2, 0.01, (a.z + b.z) / 2)
    let planeMesh = MeshResource.generatePlane(width: len, height: width) // –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–∏–ø–∞ Float :contentReference[oaicite:7]{index=7}
    var segMat = UnlitMaterial()
    segMat.color = .init(tint: UIColor(white: 1.0, alpha: 0.65))
    let plane = ModelEntity(mesh: planeMesh, materials: [segMat])
    // –ü–æ–≤–µ—Ä–Ω—ë–º –ø–ª–æ—Å–∫–æ—Å—Ç—å –≤ XZ (yaw), —á—Ç–æ–±—ã –¥–ª–∏–Ω–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ —Å–æ–≤–ø–∞–ª–∞ —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —Å–µ–≥–º–µ–Ω—Ç–∞
    let yaw = atan2(dx, -dz)
    plane.transform.rotation = simd_quatf(angle: yaw, axis: [0, 1, 0])
    plane.position = mid
    return plane
}

################################################################################
FILE: LocationService.swift
SIZE: 3581 bytes

################################################################################
import Foundation
import CoreLocation
import Observation

@MainActor
@Observable
final class LocationService: NSObject {
    enum Status {
        case idle, requesting, authorized, denied, restricted
    }

    private let manager = CLLocationManager()

    // –ü—É–±–ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    var status: Status = .idle
    var currentLocation: CLLocation?
    var lastMeterSnapLocation: CLLocation?

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
    var distanceThresholdMeters: CLLocationDistance = 1.0   // ¬´–∫–∞–∂–¥—ã–π –º–µ—Ç—Ä¬ª
    var desiredAccuracy: CLLocationAccuracy = kCLLocationAccuracyBest

    override init() {
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = desiredAccuracy
        manager.distanceFilter = kCLDistanceFilterNone // –ø—É—Å—Ç—å –æ—Ç–¥–∞—ë—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —á–∞—Å—Ç–æ, —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å–∞–º–∏
        manager.activityType = .fitness                // –ø–µ—à–µ—Ö–æ–¥–Ω—ã–π –∫–µ–π—Å; –º–æ–∂–Ω–æ .otherNavigation
        manager.pausesLocationUpdatesAutomatically = true
    }

    func requestAuthorizationIfNeeded() {
        switch manager.authorizationStatus {
        case .notDetermined:
            status = .requesting
            manager.requestWhenInUseAuthorization()
        case .authorizedAlways, .authorizedWhenInUse:
            status = .authorized
        case .denied:
            status = .denied
        case .restricted:
            status = .restricted
        @unknown default:
            status = .restricted
        }
    }

    func start() {
        requestAuthorizationIfNeeded()
        if case .authorized = status {
            manager.startUpdatingLocation()
        }
    }

    func stop() {
        manager.stopUpdatingLocation()
    }

    /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π ¬´–∑–∞—â—ë–ª–∫–Ω—É—Ç–æ–π¬ª —Ç–æ—á–∫–∏ –ø—Ä–æ–π–¥–µ–Ω–æ >= threshold
    @discardableResult
    func checkAndSnapIfNeeded(threshold: CLLocationDistance? = nil) -> Bool {
        guard let loc = currentLocation else { return false }
        let thr = threshold ?? distanceThresholdMeters
        if let last = lastMeterSnapLocation {
            if loc.distance(from: last) >= thr {
                lastMeterSnapLocation = loc
                return true
            }
            return false
        } else {
            lastMeterSnapLocation = loc
            return true
        }
    }
}

extension LocationService: CLLocationManagerDelegate {
    nonisolated func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        Task { @MainActor in
            switch manager.authorizationStatus {
            case .authorizedAlways, .authorizedWhenInUse:
                status = .authorized
                self.manager.startUpdatingLocation()
            case .denied:
                status = .denied
            case .restricted:
                status = .restricted
            case .notDetermined:
                status = .requesting
            @unknown default:
                status = .restricted
            }
        }
    }

    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let latest = locations.last else { return }
        Task { @MainActor in
            currentLocation = latest
        }
    }

    nonisolated func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        // –ú–æ–∂–Ω–æ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å/–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        // print("Location error:", error.localizedDescription)
    }
}

################################################################################
FILE: NavigationAPIClient.swift
SIZE: 11756 bytes

################################################################################
import Foundation
import CoreLocation

// MARK: - Navigation API Client

/// Lightweight client for 2GIS navigation-related APIs (Routing, Map Matching, Radar).
struct NavigationAPIClient {

    // MARK: Configuration

    struct Configuration: Sendable {
        let routingBaseURL: URL
        let radarBaseURL: URL

        static let production = Configuration(
            routingBaseURL: URL(string: "https://routing.api.2gis.com")!,
            radarBaseURL: URL(string: "https://radar.api.2gis.com")!
        )
    }

    // MARK: Errors

    enum APIError: LocalizedError {
        case invalidURL
        case httpError(statusCode: Int, body: Data)
        case decoding(DecodingError)          // –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ DecodingError (—á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å, —á—Ç–æ –∏–º–µ–Ω–Ω–æ –Ω–µ —Ç–∞–∫)
        case decodingOther(Error)             // –Ω–∞ —Å–ª—É—á–∞–π –¥—Ä—É–≥–æ–π –æ—à–∏–±–∫–∏ –ø—Ä–∏ decode()

        var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å URL –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞."
            case let .httpError(statusCode, _):
                return "–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å-–∫–æ–¥ \(statusCode)."
            case let .decoding(err):
                return "–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞: \(err)"
            case let .decodingOther(err):
                return "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞: \(err.localizedDescription)"
            }
        }
    }

    // MARK: Core

    private let apiKey: String
    private let session: URLSession
    private let configuration: Configuration
    private let encoder: JSONEncoder
    private let decoder: JSONDecoder

    init(
        apiKey: String,
        session: URLSession = .shared,
        configuration: Configuration = .production
    ) {
        self.apiKey = apiKey
        self.session = session
        self.configuration = configuration

        let enc = JSONEncoder()
        enc.keyEncodingStrategy = .convertToSnakeCase
        enc.dateEncodingStrategy = .secondsSince1970
        self.encoder = enc

        let dec = JSONDecoder()
        dec.keyDecodingStrategy = .convertFromSnakeCase
        dec.dateDecodingStrategy = .secondsSince1970
        self.decoder = dec
    }
}

// MARK: - Public API

extension NavigationAPIClient {

    /// POST /routing/7.0.0/global?key=...
    func buildRoute(_ request: RouteRequest) async throws -> RouteResponse {
        let url = try url(base: configuration.routingBaseURL, pathComponents: ["routing", "7.0.0", "global"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: RouteResponse.self)
    }

    /// POST /map_matching/1.0.0?key=...
    func mapMatch(_ request: MapMatchRequest) async throws -> MapMatchResponse {
        let url = try url(base: configuration.routingBaseURL, pathComponents: ["map_matching", "1.0.0"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: MapMatchResponse.self)
    }

    /// POST /v2/geolocation?key=...
    func geolocate(_ request: GeolocationRequest) async throws -> GeolocationResponse {
        let url = try url(base: configuration.radarBaseURL, pathComponents: ["v2", "geolocation"], key: apiKey)
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("application/json", forHTTPHeaderField: "Accept")
        req.httpBody = try encoder.encode(request)
        return try await send(req, decode: GeolocationResponse.self)
    }
}

// MARK: - Request helpers

private extension NavigationAPIClient {

    /// –°–æ–±–∏—Ä–∞–µ—Ç URL –∏–∑ –±–∞–∑–æ–≤–æ–≥–æ –¥–æ–º–µ–Ω–∞ + path components, –¥–æ–±–∞–≤–ª—è–µ—Ç `key` –∫–∞–∫ query item.
    func url(base: URL, pathComponents: [String], key: String) throws -> URL {
        var url = base
        for p in pathComponents {
            url.appendPathComponent(p)
        }
        guard var comps = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
            throw APIError.invalidURL
        }
        var q: [URLQueryItem] = comps.queryItems ?? []
        q.append(URLQueryItem(name: "key", value: key))
        comps.queryItems = q
        guard let final = comps.url else { throw APIError.invalidURL }
        return final
    }

    func send<Response: Decodable>(_ request: URLRequest, decode type: Response.Type) async throws -> Response {
        #if DEBUG
        debugPrint("‚û°Ô∏è \(request.httpMethod ?? "GET") \(request.url?.absoluteString ?? "")")
        if let body = request.httpBody, let s = String(data: body, encoding: .utf8) {
            debugPrint("‚û°Ô∏è Body:\n\(s)")
        }
        #endif

        let (data, response) = try await session.data(for: request)

        guard let http = response as? HTTPURLResponse else {
            throw APIError.invalidURL
        }

        #if DEBUG
        debugPrint("‚¨ÖÔ∏è Status: \(http.statusCode)")
        if let s = String(data: data, encoding: .utf8) {
            debugPrint("‚¨ÖÔ∏è Raw JSON (\(data.count) bytes):\n\(s)")
        }
        #endif

        guard (200..<300).contains(http.statusCode) else {
            throw APIError.httpError(statusCode: http.statusCode, body: data)
        }

        do {
            return try decoder.decode(Response.self, from: data)
        } catch let decErr as DecodingError {
            throw APIError.decoding(decErr)
        } catch {
            throw APIError.decodingOther(error)
        }
    }
}

// MARK: - Routing models

struct RouteRequest: Encodable {
    enum Output: String, Codable { case summary, detailed }

    var points: [RoutePoint]
    var transport: String?           // "driving", "walking", "bicycle", "scooter", "motorcycle", "truck", "taxi"
    var filters: [String]?           // e.g. ["dirt_road","toll_road","ferry"]
    var output: Output?              // summary | detailed (default detailed)
    var locale: String?              // "en", "ru", ...
    var avoid: [String]?             // area/road types to avoid

    init(
        points: [RoutePoint],
        transport: String? = nil,
        filters: [String]? = nil,
        output: Output? = .detailed,
        locale: String? = nil,
        avoid: [String]? = nil
    ) {
        self.points = points
        self.transport = transport
        self.filters = filters
        self.output = output
        self.locale = locale
        self.avoid = avoid
    }
}

struct RoutePoint: Codable {
    enum PointType: String, Codable { case walking, stop, pref }
    var lon: Double
    var lat: Double
    var type: PointType
    var start: Bool?

    init(lon: Double, lat: Double, type: PointType, start: Bool? = nil) {
        self.lon = lon
        self.lat = lat
        self.type = type
        self.start = start
    }
}

struct RouteResponse: Decodable {
    let message: String?
    let query: [String: JSONValue]?   // —Å–µ—Ä–≤–µ—Ä –º–æ–∂–µ—Ç —ç—Ö–æ-–≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∑–∞–ø—Ä–æ—Å
    let result: [RouteResult]?        // –¥–µ–ª–∞–µ–º optional: –∏–Ω–æ–≥–¥–∞ —Å–µ—Ä–≤–∏—Å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ message
}

struct RouteResult: Decodable {
    let algorithm: String?
    let id: String?
    let maneuvers: [Maneuver]?
    let filterRoadTypes: [String]?
}

struct Maneuver: Decodable {
    let id: String?
    let comment: String?
    let icon: String?
    let outcomingPath: Segment?
    let outcomingPathComment: String?

    struct Segment: Decodable {
        let distance: Double?
        let duration: Double?
        let geometry: [SegmentGeometry]?
    }
}

struct SegmentGeometry: Decodable, Identifiable {
    let id = UUID()
    let color: String?
    let length: Double?
    let selection: String?   // WKT LINESTRING
    let style: String?

    private enum CodingKeys: String, CodingKey { case color, length, selection, style }
}

// MARK: - Map matching models

struct MapMatchRequest: Encodable {
    var query: [RecordedPoint]

    init(query: [RecordedPoint]) {
        self.query = query
    }
}

struct RecordedPoint: Codable {
    var lon: Double
    var lat: Double
    var utc: Int
    var speed: Double?
    var azimuth: Double?

    init(lon: Double, lat: Double, utc: Int, speed: Double? = nil, azimuth: Double? = nil) {
        self.lon = lon
        self.lat = lat
        self.utc = utc
        self.speed = speed
        self.azimuth = azimuth
    }
}

struct MapMatchResponse: Decodable {
    let distance: Double?
    let duration: Double?
    let edges: [MatchedEdge]?
    let query: [MatchedQueryPoint]?
    let route: String?
    let status: String?
}

struct MatchedEdge: Decodable, Identifiable {
    let edgeId: Int
    let distance: Double?
    let geometry: String?

    var id: Int { edgeId }
}

struct MatchedQueryPoint: Decodable, Identifiable {
    let utc: Int
    let lon: Double?
    let lat: Double?
    let lonMatched: Double?
    let latMatched: Double?
    let edgeId: Int?
    let speed: Double?
    let azimuth: Double?

    var id: Int { utc }
}

// MARK: - Radar geolocation models

struct GeolocationRequest: Encodable {
    var sessionUUID: String
    var captureTimestampUnix: Int
    var gnssLocation: GnssLocation?
    var mobileNetwork: MobileNetwork?
    var wifiAccessPoints: [WifiAccessPoint]?

    struct GnssLocation: Codable {
        var latitude: Double
        var longitude: Double
        var horizontalAccuracyM: Double?
    }

    struct MobileNetwork: Codable {
        var homeMobileCountryCode: Int
        var homeMobileNetworkCode: Int
        var cellTowers: [CellTower]
    }

    struct CellTower: Codable {
        var cellID: Int
        var networkType: String
        var locationAreaCode: Int
        var signalStrengthDBm: Int?
        var ageMs: Int?
    }

    struct WifiAccessPoint: Codable {
        var macAddress: String
        var signalStrengthDBm: Int?
        var ageMs: Int?
    }
}

struct GeolocationResponse: Decodable {
    let statusCode: Int?
    let state: String?
    let location: Location?

    struct Location: Decodable {
        let longitude: Double?
        let latitude: Double?
        let accuracy: Double?
    }
}

// MARK: - JSONValue (–¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã—Ö –∫—É—Å–æ—á–∫–æ–≤ JSON)

/// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π JSON —É–∑–µ–ª (null/bool/number/string/array/object)
enum JSONValue: Decodable {
    case null
    case bool(Bool)
    case number(Double)
    case string(String)
    case array([JSONValue])
    case object([String: JSONValue])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if container.decodeNil() { self = .null; return }
        if let b = try? container.decode(Bool.self) { self = .bool(b); return }
        if let d = try? container.decode(Double.self) { self = .number(d); return }
        if let s = try? container.decode(String.self) { self = .string(s); return }
        if let arr = try? container.decode([JSONValue].self) { self = .array(arr); return }
        if let obj = try? container.decode([String: JSONValue].self) { self = .object(obj); return }
        throw DecodingError.dataCorruptedError(in: container, debugDescription: "Unsupported JSON type")
    }
}

################################################################################
FILE: NavigationViewModel.swift
SIZE: 5383 bytes

################################################################################
import Foundation
import Observation

@MainActor
@Observable
class NavigationViewModel {
    private let client: NavigationAPIClient

    var isLoading: Bool = false
    var lastRouteResponse: RouteResponse?
    var lastMapMatchResponse: MapMatchResponse?
    var lastGeolocationResponse: GeolocationResponse?
    var errorMessage: String?

    init(client: NavigationAPIClient = NavigationAPIClient(apiKey: "6fe4cc7a-89b8-4aec-a5c3-ac94224044fe")) {
        self.client = client
    }

    func loadSampleRoute(locationService: LocationService, destinationPoint: RoutePoint) async {
        await execute {
            let currentLocation = locationService.currentLocation;
            
            
            if (currentLocation == nil) {
                debugPrint("Use mock instead")
            }
            
            let request = RouteRequest(
                points: [
                    RoutePoint(lon: currentLocation?.coordinate.longitude ?? 104.798401, lat: currentLocation?.coordinate.latitude ?? 51.877124, type: .stop),
                    destinationPoint
                ],
                transport: "walking",
                output: .detailed,
                locale: "ru"
            )
            lastRouteResponse = try await client.buildRoute(request)
        }
    }

    func loadSampleMapMatch() async {
        await execute {
            let baseTimestamp = Int(Date().timeIntervalSince1970) - 120
            let request = MapMatchRequest(
                query: [
                    RecordedPoint(lon: 37.582591, lat: 55.775364, utc: baseTimestamp, speed: 5.0, azimuth: 95),
                    RecordedPoint(lon: 37.610000, lat: 55.772300, utc: baseTimestamp + 30, speed: 6.2, azimuth: 110),
                    RecordedPoint(lon: 37.633200, lat: 55.769500, utc: baseTimestamp + 60, speed: 6.8, azimuth: 115),
                    RecordedPoint(lon: 37.656625, lat: 55.765036, utc: baseTimestamp + 90, speed: 5.4, azimuth: 118)
                ]
            )
            lastMapMatchResponse = try await client.mapMatch(request)
        }
    }

    func loadSampleGeolocation() async {
        await execute {
            let request = GeolocationRequest(
                sessionUUID: UUID().uuidString,
                captureTimestampUnix: Int(Date().timeIntervalSince1970),
                gnssLocation: .init(latitude: 55.770200, longitude: 37.620500, horizontalAccuracyM: 50),
                mobileNetwork: .init(
                    homeMobileCountryCode: 250,
                    homeMobileNetworkCode: 99,
                    cellTowers: [
                        .init(cellID: 42012345, networkType: "lte", locationAreaCode: 41001, signalStrengthDBm: -65, ageMs: 500)
                    ]
                ),
                wifiAccessPoints: [
                    .init(macAddress: "00:11:22:33:44:55", signalStrengthDBm: -45, ageMs: 300),
                    .init(macAddress: "66:77:88:99:AA:BB", signalStrengthDBm: -60, ageMs: 200)
                ]
            )
            lastGeolocationResponse = try await client.geolocate(request)
        }
    }

    private func execute(_ operation: @Sendable @MainActor () async throws -> Void) async {
        guard !isLoading else { return }
        isLoading = true
        errorMessage = nil
        do {
            try await operation()
        } catch {
            errorMessage = (error as? LocalizedError)?.errorDescription ?? error.localizedDescription
        }
        isLoading = false
    }

    // MARK: - Extract maneuver nodes and full polyline
    func extractManeuverNodes(from response: RouteResponse) -> [ManeuverNode] {
        guard let route = response.result?.first, let mans = route.maneuvers else { return [] }
        return mans.compactMap { m in
            guard let sel = m.outcomingPath?.geometry?.first?.selection else { return nil }
            guard let first = WKT.parseLineString(sel).first else { return nil }
            let icon = (m.icon ?? "")
            let title: String = (icon == "turn_right") ? "‚Ü±" :
                                (icon == "turn_left")  ? "‚Ü∞" :
                                (icon == "finish")     ? "‚óè" :
                                (icon == "start")      ? "‚óé" : "‚¨ÜÔ∏é"
            return ManeuverNode(lon: first.lon, lat: first.lat, title: title, detail: m.outcomingPathComment ?? m.comment)
        }
    }

    func extractFullPolyline(from response: RouteResponse) -> RoutePolyline {
        guard let route = response.result?.first, let mans = route.maneuvers else {
            return .init(points: [])
        }
        var all: [GeoPoint] = []
    
        for m in mans {
            if let sel = m.outcomingPath?.geometry?.first?.selection {
                let pts = WKT.parseLineString(sel) // [(lon, lat)]
                guard !pts.isEmpty else { continue }
                // –°–∫–ª–µ–∏–≤–∞–µ–º, –∏–∑–±–µ–≥–∞—è –¥—É–±–ª—è –ø–µ—Ä–≤–æ–π –≤–µ—Ä—à–∏–Ω—ã
                if let last = all.last, let first = pts.first,
                   last.lon == first.lon, last.lat == first.lat {
                    all.append(contentsOf: pts.dropFirst().map { GeoPoint(lon: $0.lon, lat: $0.lat) })
                } else {
                    all.append(contentsOf: pts.map { GeoPoint(lon: $0.lon, lat: $0.lat) })
                }
            }
        }
        return .init(points: all)
    }

}

################################################################################
FILE: PlacesClient.swift
SIZE: 5475 bytes

################################################################################
//
//  PlacesClient.swift
//  2gis
//
//  Created by –ü–∞–≤–µ–ª on 05.10.2025.
//

import Foundation

public struct DGisPlacesClient {
    public struct Config {
        public var apiKey: String
        public var baseURL: URL
        public init(apiKey: String,
                    baseURL: URL = URL(string: "https://catalog.api.2gis.com/3.0")!) {
            self.apiKey = apiKey
            self.baseURL = baseURL
        }
    }

    public enum ClientError: Error, LocalizedError {
        case invalidURL
        case http(Int)
        case emptyResult
        public var errorDescription: String? {
            switch self {
            case .invalidURL: return "Invalid URL"
            case .http(let code): return "HTTP error \(code)"
            case .emptyResult: return "No items found"
            }
        }
    }

    public struct Point: Decodable {
        public let lon: Double?
        public let lat: Double?
    }

    public struct PlaceItem: Decodable {
        public let id: String
        public let name: String
        public let addressName: String?
        public let point: Point?

        private enum CodingKeys: String, CodingKey {
            case id, name, point
            case addressName = "address_name"
        }
    }

    public struct Meta: Decodable {
        public let code: Int?
        public let total: Int?
        public let page: Int?
        public let pageSize: Int?

        private enum CodingKeys: String, CodingKey {
            case code, total, page
            case pageSize = "page_size"
        }
    }

    public struct PlacesResultBlock: Decodable {
        public let items: [PlaceItem]?
    }

    public struct PlacesResponse: Decodable {
        public let meta: Meta?
        public let result: PlacesResultBlock?
    }

    private let config: Config
    private let session: URLSession

    public init(config: Config, session: URLSession = .shared) {
        self.config = config
        self.session = session
    }

    /// –ü–æ–∏—Å–∫ –º–µ—Å—Ç –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–∫–∞–∑—ã–≤–∞—Ç—å –≥–æ—Ä–æ–¥ –≤ —Ç–µ–∫—Å—Ç–µ –∑–∞–ø—Ä–æ—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "Moscow cafe") –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. 2GIS —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–∞–≥–∏–Ω–∞—Ü–∏—é `page`/`page_size` –∏ —Å–ø–∏—Å–æ–∫ –ø–æ–ª–µ–π `fields`.
    /// –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: /3.0/items?q=...&key=... (+ page, page_size, fields)
    /// - Parameters:
    ///   - name: –¢–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "Coffee Like" –∏–ª–∏ "Moscow cafe").
    ///   - cityHint: –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ –≥–æ—Ä–æ–¥–∞; –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫ –∑–∞–ø—Ä–æ—Å—É (—Å–º. —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ 2GIS).
    ///   - page: –ù–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1).
    ///   - pageSize: –†–∞–∑–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã (1...50).
    ///   - fields: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è, –Ω–∞–ø—Ä–∏–º–µ—Ä: ["items.point","items.address_name"].
    /// - Returns: –†–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –∏ —Å–ø–∏—Å–∫–æ–º –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤.
    public func searchPlacesByName(
        _ name: String,
        cityHint: String? = nil,
        page: Int = 1,
        pageSize: Int = 12,
        fields: [String] = ["items.point","items.address_name"]
    ) async throws -> PlacesResponse {
        // –°–±–æ—Ä–∫–∞ q —Å —É—á—ë—Ç–æ–º cityHint (–ø–æ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ 2GIS –¥–æ–±–∞–≤–ª—è—Ç—å –≥–æ—Ä–æ–¥ –≤ —Ç–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞).
        // –°–º. –ø—Ä–∏–º–µ—Ä: `q=Moscow cafe&type=branch&key=...`
        let q: String = {
            if let city = cityHint?.trimmingCharacters(in: .whitespacesAndNewlines), !city.isEmpty {
                return "\(city) \(name)"
            } else {
                return name
            }
        }()

        var comps = URLComponents(url: config.baseURL.appendingPathComponent("items"), resolvingAgainstBaseURL: false)
        comps?.queryItems = [
            URLQueryItem(name: "q", value: q),
            URLQueryItem(name: "page", value: String(page)),
            URLQueryItem(name: "page_size", value: String(pageSize)),
            URLQueryItem(name: "key", value: config.apiKey)
        ]

        if !fields.isEmpty {
            comps?.queryItems?.append(URLQueryItem(name: "fields", value: fields.joined(separator: ",")))
        }

        guard let url = comps?.url else { throw ClientError.invalidURL }

        var req = URLRequest(url: url)
        req.httpMethod = "GET"

        let (data, resp) = try await session.data(for: req)
        if let http = resp as? HTTPURLResponse, !(200...299).contains(http.statusCode) {
            throw ClientError.http(http.statusCode)
        }

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .useDefaultKeys

        let dto = try decoder.decode(PlacesResponse.self, from: data)
        return dto
    }

    /// –£–¥–æ–±–Ω—ã–π —Ö–µ–ª–ø–µ—Ä: –≤–µ—Ä–Ω—É—Ç—å –ª—É—á—à–∏–π (–ø–µ—Ä–≤—ã–π) –º–∞—Ç—á, –∏–Ω–∞—á–µ –æ—à–∏–±–∫–∞.
    public func bestMatch(
        _ name: String,
        cityHint: String? = nil,
        fields: [String] = ["items.point","items.address_name"]
    ) async throws -> PlaceItem {
        let response = try await searchPlacesByName(name, cityHint: cityHint, page: 1, pageSize: 1, fields: fields)
        if let first = response.result?.items?.first {
            return first
        } else {
            throw ClientError.emptyResult
        }
    }
}

################################################################################
FILE: RouteOverlayModels.swift
SIZE: 2250 bytes

################################################################################
import Foundation
import simd

// –£–∑–µ–ª –º–∞–Ω—ë–≤—Ä–∞ –¥–ª—è –æ–∫–æ–Ω-–±–∏–ª–±–æ—Ä–¥–æ–≤
public struct ManeuverNode: Identifiable, Codable, Hashable, Sendable {
    public let id: UUID
    public let lon: Double
    public let lat: Double
    public let title: String
    public let detail: String?

    public init(id: UUID = UUID(), lon: Double, lat: Double, title: String, detail: String?) {
        self.id = id
        self.lon = lon
        self.lat = lat
        self.title = title
        self.detail = detail
    }
}

// üëá –ù–û–í–û–ï: –Ω–æ–º–∏–Ω–∞–ª—å–Ω—ã–π —Ç–∏–ø –≤–º–µ—Å—Ç–æ –∫–æ—Ä—Ç–µ–∂–∞
public struct GeoPoint: Codable, Hashable, Sendable {
    public let lon: Double
    public let lat: Double
    public init(lon: Double, lat: Double) {
        self.lon = lon
        self.lat = lat
    }
}

// –ü–æ–ª–∏–ª–∏–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞ (—Ç–µ–ø–µ—Ä—å –Ω–∞ GeoPoint, –∞ –Ω–µ –Ω–∞ tuple)
public struct RoutePolyline: Codable, Hashable, Sendable, Equatable {
    public var points: [GeoPoint]
    public init(points: [GeoPoint]) {
        self.points = points
    }
}

// –ü–æ–ª–µ–∑–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã
public enum Geo {
    public static let metersPerDeg: Double = 111_320.0
    public static func geoToMeters(lon: Double, lat: Double, originLon: Double, originLat: Double) -> SIMD2<Double> {
        let dx = (lon - originLon) * cos(originLat * .pi / 180.0) * metersPerDeg
        let dz = (lat - originLat) * metersPerDeg
        return .init(dx, dz)
    }
}

public enum WKT {
    // LINESTRING(lon lat, lon lat, ...)
    public static func parseLineString(_ wkt: String) -> [(lon: Double, lat: Double)] {
        let up = wkt.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()
        guard up.hasPrefix("LINESTRING"),
              let l = wkt.firstIndex(of: "("),
              let r = wkt.lastIndex(of: ")"),
              l < r
        else { return [] }
        let inner = wkt[wkt.index(after: l)..<r]
        return inner.split(separator: ",").compactMap { pair in
            let comps = pair.trimmingCharacters(in: .whitespaces).split(separator: " ")
            guard comps.count >= 2, let lon = Double(comps[0]), let lat = Double(comps[1]) else { return nil }
            return (lon, lat)
        }
    }
}

################################################################################
FILE: SignpostWindow.swift
SIZE: 629 bytes

################################################################################
import SwiftUI

struct SignpostWindow: View {
    let node: ManeuverNode

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(node.title).font(.title2).bold()
            if let d = node.detail { Text(d).font(.footnote) }
        }
        .padding(12)
        .background(.thinMaterial, in: RoundedRectangle(cornerRadius: 14))
        .navigationTitle("–ù–∞–≤–∏–≥–∞—Ü–∏—è")
        .toolbar {
            ToolbarItem(placement: .status) {
                Text("–¢–æ—á–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞").font(.footnote).foregroundStyle(.secondary)
            }
        }
        .padding(8)
    }
}

################################################################################
FILE: ToggleImmersiveSpaceButton.swift
SIZE: 2365 bytes

################################################################################
//
//  ToggleImmersiveSpaceButton.swift
//  2gis
//
//  Created by –ü–∞–≤–µ–ª on 04.10.2025.
//

import SwiftUI

struct ToggleImmersiveSpaceButton: View {

    @Environment(AppModel.self) private var appModel

    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace

    var body: some View {
        Button {
            Task { @MainActor in
                switch appModel.immersiveSpaceState {
                    case .open:
                        appModel.immersiveSpaceState = .inTransition
                        await dismissImmersiveSpace()
                        // Don't set immersiveSpaceState to .closed because there
                        // are multiple paths to ImmersiveView.onDisappear().
                        // Only set .closed in ImmersiveView.onDisappear().

                    case .closed:
                        appModel.immersiveSpaceState = .inTransition
                        switch await openImmersiveSpace(id: appModel.immersiveSpaceID) {
                            case .opened:
                                // Don't set immersiveSpaceState to .open because there
                                // may be multiple paths to ImmersiveView.onAppear().
                                // Only set .open in ImmersiveView.onAppear().
                                break

                            case .userCancelled, .error:
                                // On error, we need to mark the immersive space
                                // as closed because it failed to open.
                                fallthrough
                            @unknown default:
                                // On unknown response, assume space did not open.
                                appModel.immersiveSpaceState = .closed
                        }

                    case .inTransition:
                        // This case should not ever happen because button is disabled for this case.
                        break
                }
            }
        } label: {
            Text(appModel.immersiveSpaceState == .open ? "Hide Immersive Space" : "Show Immersive Space")
        }
        .disabled(appModel.immersiveSpaceState == .inTransition)
        .animation(.none, value: 0)
        .fontWeight(.semibold)
    }
}

################################################################################
FILE: _gisApp.swift
SIZE: 956 bytes

################################################################################
// _gisApp.swift
import SwiftUI

@main
struct _gisApp: App {
    @State private var appModel = AppModel()

    var body: some Scene {
        // –ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ (–∫–∞–∫ –±—ã–ª–æ)
        WindowGroup {
            ContentView()
                .environment(appModel)
        }
        .defaultSize(CGSize(width: 900, height: 800))

        // üëá –ù–æ–≤–æ–µ: –≥—Ä—É–ø–ø–∞ –æ–∫–æ–Ω-¬´–±–∏–ª–±–æ—Ä–¥–æ–≤¬ª –ø–æ –∑–Ω–∞—á–µ–Ω–∏—è–º —É–∑–ª–æ–≤
        WindowGroup(id: "SignpostWindow", for: ManeuverNode.self) { $node in
            if let node {
                SignpostWindow(node: node)
                    .environment(appModel)
            } else {
                // fallback –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∑–Ω–∞—á–µ–Ω–∏—è
                Text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö —Ç–æ—á–∫–∏")
                    .padding()
            }
        }
        .defaultSize(CGSize(width: 260, height: 130))
        .windowResizability(.contentSize)
    }
}

